<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[BIO、NIO与AIO(一)]]></title>
      <url>/2018/03/01/BIO%E3%80%81NIO%E4%B8%8EAIO-%E4%B8%80/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文对<code>java</code>中三种<code>I/O</code>方式的用法以及性能进行比较。这三种<code>I/0</code>方式对应着五大模型中的阻塞模型、多路复用模型、异步模型。<code>I/O</code>的应用场景通常包含磁盘<code>I/O</code>和网络<code>I/O</code>,本文从这两个方面介绍三种<code>IO</code>方式，比较三者之间的性能。<br><a id="more"></a></p>
</blockquote>
<h1 id="传统IO-BIO"><a href="#传统IO-BIO" class="headerlink" title="传统IO-BIO"></a>传统IO-BIO</h1><p><code>Java.io</code> 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。<code>Java.io</code> 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p>
<h2 id="IO流处理类"><a href="#IO流处理类" class="headerlink" title="IO流处理类"></a>IO流处理类</h2><p><code>Java.io</code> 包中输入流和输出流的类层次图如下：<br><img src="IO流.png" alt="输入流和输出流的类层次图"></p>
<h2 id="IO流处理类分类"><a href="#IO流处理类分类" class="headerlink" title="IO流处理类分类"></a>IO流处理类分类</h2><p>根据数据处理类型的不同，可将<code>IO流</code>分为字符流和字节流。因为数据编码的不同，而有了对字符进行高效操作的流对象，其本质就是基于字节流读取时，去查了指定的码表。所以<code>java</code>在操作字符流时必须指定字符编码，若果不指定，则使用默认的编码(<code>Unicode</code>)。<br>字符流和字节流的区别：</p>
<ul>
<li>读写单位不同：字节流一字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（例如图片，avi），而字符流只能处理字符类型的数据。</li>
<li>字节流操作的时候本身是不会用到缓冲区的，是对文件本身的直接操作。而字符流在操作的时候是会用到缓冲区的，通过缓冲区来操作文件。</li>
</ul>
<p>字符流是为了简化开发提出来的流对象，其底层操作的还是字节流。所以字节流比字符流效率更高。<br>在字节流中。<code>ByteArrayInputStream</code>、<code>StringBufferInputStream</code>、<code>FileInputStream</code> 是三种基本的介质流，它们分别从<code>Byte</code>数组、<code>StringBuffer</code>、和本地文件中读取数据。<code>PipedInputStream</code> 是从与其它线程共用的管道中读取数据。<br><code>ObjectInputStream</code> 和所有<code>FilterInputStream</code>的子类都是装饰流（装饰器模式的主角）。意思是<code>FileInputStream</code>类可以通过一个<code>String</code>路径名创建一个对象，<code>FileInputStream(String name)</code>。而<code>DataInputStream</code>必须装饰一个类才能返回一个对象，<code>DataInputStream(InputStream in)</code>。<br><code>ByteArrayOutputStream</code>、<code>FileOutputStream</code>是两种基本的介质流，它们分别向<code>Byte</code> 数组、和本地文件中写入数据。<code>PipedOutputStream</code> 是向与其它线程共用的管道中写入数据，<code>ObjectOutputStream</code> 和所有<code>FilterOutputStream</code>的子类都是装饰流。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="向文件中写入2000M的内容"><a href="#向文件中写入2000M的内容" class="headerlink" title="向文件中写入2000M的内容"></a>向文件中写入2000M的内容</h3><p>一字节一字节的输出</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByBIO</span><span class="params">()</span></span>{
    <span class="keyword">long</span> length = <span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>;
    <span class="keyword">byte</span> b = <span class="number">1</span>;
    File tmp = <span class="keyword">new</span> File(<span class="string">"E:\\tmp.dat"</span>);
    FileOutputStream output = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (!tmp.exists()) {
           tmp.createNewFile();
        }
        output = <span class="keyword">new</span> FileOutputStream(tmp);
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (length -- &gt; <span class="number">0</span>) {
            output.write(b);
        }
        System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span>(output != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                output.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>单字节的写入非常耗时,上面代码最终耗时<code>3828580ms</code>，<code>FileOutputStream.write(int)</code>调用<code>native method write(int)</code>。<code>...\jdk\src\share\native\java\io\io_util.c</code>中提供两个方法<code>writeSingle</code>和<code>writeBytes</code>,二者最终调用系统的<code>write</code>方法。</p>
<pre><code class="c++"><span class="comment">/* Write N bytes of BUF to FD.  Return the number written, or -1.</span>
<span class="comment"></span>
<span class="comment">   This function is a cancellation point and therefore not marked with</span>
<span class="comment">   __THROW.  */</span>
   <span class="comment">//fd:文件描述符,buf:字节内容,n:字节长度</span>
<span class="function"><span class="keyword">extern</span> ssize_t <span class="title">write</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n)</span> __wur</span>;
</code></pre>
<p>由于阻塞模型，系统在写入文件时要和内核空间交互，<code>cpu</code>在用户和内核状态来回切换，用户线程不断阻塞，所以非常耗时。可以改造上面的方法，一次写入多个字节，减少系统写入方法的调用（<code>IO次数</code>）。牺牲内存空间来提高效率。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByBIO2</span><span class="params">()</span></span>{
    <span class="keyword">long</span> length = <span class="number">2000</span>;
    .........
    <span class="keyword">byte</span>[] byteArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];
    <span class="comment">//一次写入1M的内容</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) {
        byteArr[i] = <span class="number">1</span>;
    }
    <span class="keyword">long</span> start = System.currentTimeMillis();
    <span class="keyword">while</span> (length -- &gt; <span class="number">0</span>) {
        output.write(byteArr);
    }
    System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    ...
}
写入时间:<span class="number">10043</span>ms
</code></pre>
<p>使用<code>BufferedOutputStream</code>从源码看,其实和第二种方式类似。但时间却差了好几十倍，原因不明，有可能是因为<code>synchronized</code>关键字的原因，参考[<a href="https://stackoverflow.com/questions/49065340/why-fileinputstream-is-much-faster-then-bufferedinputstream-with-the-same-buffer?answertab=oldest#tab-top]。" target="_blank" rel="noopener">https://stackoverflow.com/questions/49065340/why-fileinputstream-is-much-faster-then-bufferedinputstream-with-the-same-buffer?answertab=oldest#tab-top]。</a></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByBIO3</span><span class="params">()</span></span>{
    ..........
    <span class="keyword">long</span> length = <span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>;
    <span class="keyword">try</span> {
        ....
        output = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp),<span class="number">1024</span> * <span class="number">1024</span>);
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (length -- &gt; <span class="number">0</span>) {
            output.write(<span class="number">1</span>);
        }
        System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } 
    .......
}
写入时间:<span class="number">48568</span>ms
</code></pre>
<h3 id="读取刚刚的文件"><a href="#读取刚刚的文件" class="headerlink" title="读取刚刚的文件"></a>读取刚刚的文件</h3><p>单字节读取,跟写入时情况相同，超级慢。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromFileByBIO1</span><span class="params">()</span></span>{
    File tmp = <span class="keyword">new</span> File(<span class="string">"E:\\tmp.dat"</span>);
    FileInputStream is = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        is = <span class="keyword">new</span> FileInputStream(tmp);
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (is.read() &gt; -<span class="number">1</span>) {

        }
        System.out.println(<span class="string">"读取时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span>(is != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                is.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
读取时间:<span class="number">2791450</span>ms
</code></pre>
<p>一次读取1M,非常快。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromFileByBIO1</span><span class="params">()</span></span>{
    ........
    <span class="keyword">try</span> {
        is = <span class="keyword">new</span> FileInputStream(tmp);
        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (is.read(buf) &gt; -<span class="number">1</span>) {
        }
        System.out.println(<span class="string">"读取时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } 
    .........
}
读取时间:<span class="number">1549</span>ms
</code></pre>
<p>同样，使用<code>BufferedInputStream</code>，将<code>size</code>设置为 <code>1024 * 1024</code>，比上一种方法要慢。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromFileByBIO1</span><span class="params">()</span></span>{
    ........
    <span class="keyword">try</span> {
        is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(tmp),<span class="number">1024</span> * <span class="number">1024</span>);
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (is.read() &gt; -<span class="number">1</span>) {
        }
        System.out.println(<span class="string">"读取时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } 
    .........
}
读取时间:<span class="number">51694</span>ms
</code></pre>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p><code>Java NIO</code>是<code>java 1.4</code>之后新出的一套<code>IO</code>接口，这里的的新是相对于原有标准的<code>Java IO</code>和<code>Java Networking</code>接口。NIO提供了一种完全不同的操作方式。<code>NIO</code>中的N可以理解为<code>Non-blocking</code>，不单纯是<code>New</code>。</p>
<h2 id="NIO与标准IO的区别。"><a href="#NIO与标准IO的区别。" class="headerlink" title="NIO与标准IO的区别。"></a>NIO与标准IO的区别。</h2><ul>
<li>标准的<code>IO</code>编程接口是面向字节流和字符流的。而<code>NIO</code>是面向通道和缓冲区的，数据总是从通道中读到<code>buffer缓冲区</code>内，或者从<code>buffer</code>写入到通道中。<br><img src="overview-channels-buffers.png" alt="面向通道和缓冲区"></li>
<li><code>Java NIO</code>使我们可以进行非阻塞<code>IO</code>操作(五大<code>IO</code>模型中的非阻塞模型)。比如说，单线程中从通道读取数据到<code>buffer</code>，同时可以继续做别的事情，当数据读取到<code>buffer</code>中后，线程再继续处理数据。写数据也是一样的。</li>
<li><code>Java NIO</code>的<code>Selector</code>允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。<br><img src="overview-selectors.png" alt="Selector"></li>
</ul>
<h2 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h2><p><code>buffer</code>缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被<code>NIO Buffer</code>管理，并提供一系列的方法用于更简单的操作这块内存。</p>
<h3 id="Buffer的容量，位置，上限"><a href="#Buffer的容量，位置，上限" class="headerlink" title="Buffer的容量，位置，上限"></a>Buffer的容量，位置，上限</h3><p><img src="buffers-modes.png" alt="Buffer"></p>
<ul>
<li>容量：作为一块内存，<code>buffer</code>有一个固定的大小，叫做<code>capacity</code>容量。也就是最多只能写入容量值得字节，整形等数据。一旦<code>buffer</code>写满了就需要清空已读数据以便下次继续写入新的数据。</li>
<li>位置：当写入数据到<code>Buffer</code>的时候需要中一个确定的位置开始，默认初始化时这个位置<code>position</code>为<code>0</code>，一旦写入了数据比如一个字节，整形数据，那么<code>position</code>的值就会指向数据之后的一个单元，<code>position</code>最大可以到<code>capacity-1</code>。当从<code>Buffer</code>读取数据时，也需要从一个确定的位置开始。<code>buffer</code>从写入模式变为读取模式时，<code>position</code>会归零，每次读取后，<code>position</code>向后移动。</li>
<li>上限：在写模式，<code>limit</code>的含义是我们所能写入的最大数据量。它等同于<code>buffer</code>的容量。一旦切换到读模式，<code>limit</code>则代表我们所能读取的最大数据量，他的值等同于写模式下<code>position</code>的位置。</li>
</ul>
<p><code>NIO</code>还有许多概念，像“零拷贝”、<code>Scatter / Gather</code>等。相关的解释参考<a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-scatter-gather.html" target="_blank" rel="noopener">即可学院</a>。这里以磁盘<code>IO</code>的方式比较标准<code>IO</code>与<code>NIO</code>的差别。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="向文件中写入2000M的内容-1"><a href="#向文件中写入2000M的内容-1" class="headerlink" title="向文件中写入2000M的内容"></a>向文件中写入2000M的内容</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByNIO</span><span class="params">()</span></span>{
    File tmp = <span class="keyword">new</span> File(<span class="string">"E:\\tmp.dat"</span>);
    FileChannel inChannel = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (!tmp.exists()) {
            tmp.createNewFile();
        }
        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(tmp, <span class="string">"rw"</span>);
        inChannel = aFile.getChannel();
        <span class="comment">//创建一个ByteBuffer，默认是写模式</span>
        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);
        <span class="comment">//将buffer的position设为0，limit设为capacity</span>
        buf.clear();
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j++) {
            buf.put((<span class="keyword">byte</span>) <span class="number">1</span>);
        }
        <span class="comment">//转换为读模式将limit设为原来的position，position设为0.</span>
        buf.flip();
        buf.mark();
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span> ; i ++) {
            buf.reset();
            <span class="keyword">while</span> (buf.hasRemaining()) {
                inChannel.write(buf);
            }
        }
        System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span>(inChannel != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                inChannel.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
写入时间:<span class="number">9918</span>ms
</code></pre>
<h3 id="读取刚刚的文件-1"><a href="#读取刚刚的文件-1" class="headerlink" title="读取刚刚的文件"></a>读取刚刚的文件</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromFileByNIO</span><span class="params">()</span></span>{
    FileChannel inChannel = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"E:\\tmp.dat"</span>, <span class="string">"r"</span>);
        inChannel = aFile.getChannel();
        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">while</span> (inChannel.read(buf) &gt; -<span class="number">1</span>) {
            buf.clear();
        }
        System.out.println(<span class="string">"读取时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="comment">//close code</span>
    }
}
读取时间:<span class="number">1041</span>ms
</code></pre>
<p>对于文件的读写，<code>NIO</code>和<code>BIO</code>同样都调用了系统底层的<code>read</code>和<code>write</code>方法，相同的<code>IO</code>次数的情况下，两者的效率差别不是很大，<code>NIO</code>效率较高。<code>NIO</code>只是改变了<code>IO</code>的方式，提供了更加灵活的<code>API</code>，让IO成为非阻塞的模式，在<code>IO</code>阻塞的时候程序可以做其他事情，<code>NIO</code>在网络<code>IO</code>的情况下才会发挥它明显的优势。</p>
<h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p><code>jdk7</code>中新增了一些与文件(网络)<code>I/O</code>相关的一些<code>api</code>。这些<code>API</code>被称为<code>NIO.2</code>，或称为<code>AIO(Asynchronous I/O)</code>。<code>AIO</code>最大的一个特性就是异步能力，这种能力对<code>socket</code>与文件<code>I/O</code>都起作用。<code>AIO</code>其实是一种在读写操作结束之前允许进行其他操作的<code>I/O</code>处理。<code>AIO</code>是对<code>JDK1.4</code>中提出的同步非阻塞<code>I/O(NIO)</code>的进一步增强。<code>Java AIO</code>是五大模型中异步模型的实现。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步编程提供了一个非阻塞的，事件驱动的编程模型。 这种编程模型利用系统中多核执行任务来提供并行，因此提高了应用的吞吐率。就单线程的编程而言，异步并没有提高程序的运行效率，反而增加了程序的复杂度。<code>Java</code>异步编程通常需要使用<code>Future</code>，<code>FutureTask</code>和<code>Callable</code>，其中<code>Future</code>代表未来的某个结果，一般是向线程池提交任务时返回。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFuture</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{
    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);
    List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
        <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;
        Future&lt;String&gt; future = executor.submit(() -&gt; {
            System.out.println(<span class="string">"task["</span>+ finalI +<span class="string">"] started!"</span>);
            Thread.sleep(<span class="number">1000</span>*(<span class="number">3</span>-finalI));<span class="comment">// cost some time</span>
            System.out.println(<span class="string">"task["</span>+ finalI +<span class="string">"]finished!"</span>);
            <span class="keyword">return</span> <span class="string">"result["</span>+ finalI +<span class="string">"]"</span>;
        });
        futureList.add(future);
    }

    <span class="keyword">for</span> (Future&lt;String&gt; future : futureList) {
        System.out.println(future.get());
    }
    System.out.println(<span class="string">"Main thread finished."</span>);
    executor.shutdown();
}
<span class="comment">//执行结果</span>
task[<span class="number">0</span>] started!
task[<span class="number">1</span>] started!
task[<span class="number">2</span>] started!
task[<span class="number">2</span>]finished!
task[<span class="number">1</span>]finished!
task[<span class="number">0</span>]finished!
result[<span class="number">0</span>]
result[<span class="number">1</span>]
result[<span class="number">2</span>]
Main thread finished.
</code></pre>
<p>主线程向线程池提交的三个任务同时开始执行，但是在使用<code>get</code>取结果的时候发现必须等耗时最长的任务结束之后才可以得到执行结果。也就是三个线程都结束后才返回主线程。<code>get</code>方法阻塞了主线程，在取异步任务执行结果期间主线程不可以做其他事情，这不是真正的异步执行。但这个适合分开统计，合并汇总的场景。<br><img src="Future.png" alt="Future"></p>
<h3 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestCompletionService</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{
    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);
    CompletionService&lt;String&gt; service = <span class="keyword">new</span> ExecutorCompletionService&lt;String&gt;(executor);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
        <span class="keyword">int</span> finalI = i;
        service.submit(() -&gt; {
            System.out.println(<span class="string">"task["</span>+ finalI +<span class="string">"] started!"</span>);
            Thread.sleep(<span class="number">1000</span>*(<span class="number">3</span>-finalI));<span class="comment">// cost some time</span>
            System.out.println(<span class="string">"task["</span>+ finalI +<span class="string">"]finished!"</span>);
            <span class="keyword">return</span> <span class="string">"result["</span>+ finalI +<span class="string">"]"</span>;
        });
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
        System.out.println(service.take().get());
    }
    System.out.println(<span class="string">"Main thread finished."</span>);
    executor.shutdown();
}
<span class="comment">//执行结果</span>
task[<span class="number">1</span>] started!
task[<span class="number">0</span>] started!
task[<span class="number">2</span>] started!
task[<span class="number">2</span>]finished!
result[<span class="number">2</span>]
task[<span class="number">1</span>]finished!
result[<span class="number">1</span>]
task[<span class="number">0</span>]finished!
result[<span class="number">0</span>]
Main thread finished.
</code></pre>
<p>主线程向线程池提交的三个任务同时开始执行，与<code>Future</code>不同的是三个线程完成后分别返回主线程进行处理。<code>service.take().get()</code>也会阻塞主线程。<br><img src="FutureTask.png" alt="FutureTask"></p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompletableFuture</span><span class="params">()</span></span>{
    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
        <span class="keyword">int</span> finalI = i;
        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(<span class="string">"task["</span>+finalI+<span class="string">"] started!"</span>);
            <span class="keyword">try</span> {
                <span class="comment">// time cost</span>
                Thread.sleep(<span class="number">1000</span>*(<span class="number">3</span>-finalI));
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(<span class="string">"task["</span>+finalI+<span class="string">"] finished"</span>);
            <span class="keyword">return</span> <span class="string">"result["</span>+finalI+<span class="string">"]"</span>;
        }, executor);
        future.thenAccept(System.out::println);
    }

    System.out.println(<span class="string">"Main thread finished."</span>);
    executor.shutdown();
}
<span class="comment">//执行结果</span>
Main thread finished.
task[<span class="number">0</span>] started!
task[<span class="number">1</span>] started!
task[<span class="number">2</span>] started!
task[<span class="number">2</span>] finished
result[<span class="number">2</span>]
task[<span class="number">1</span>] finished
result[<span class="number">1</span>]
task[<span class="number">0</span>] finished
result[<span class="number">0</span>]
</code></pre>
<p>主线程向线程池提交的三个任务同时开始执行，主线程只负责提交任务，任务提交完后就可以做其他事情了，主线程提交任务时给了任务回调函数，任务执行完成后调用这个函数就行了。这才是真正的异步。<br><img src="CompletableFuture.png" alt="CompletableFuture"></p>
<h2 id="文件的异步读写"><a href="#文件的异步读写" class="headerlink" title="文件的异步读写"></a>文件的异步读写</h2><p>在同步<code>IO</code>中，线程会阻塞直到系统的<code>IO</code>操作完成之后再获取操作结果。在异步<code>IO</code>中，线程只是提交读写操作请求，等到系统<code>IO</code>操作完成后会操作结果通知到线程。可以看出，<code>AIO</code>并没有加速<code>IO</code>处理速度，只是利用回调和通知机制改变了业务处理时机，使得具体逻辑可以不关注<code>IO</code>结果，只需在合理的时机添加回调即可。<br><code>java.nio.channels.AsynchronousFileChannel</code>类是<code>java</code>提供的异步文件通道。通过静态方法<code>AsynchronousFileChannel#open()</code>能获取实例。<code>AsynchronousFileChannel</code>类提供了两种方式去处理系统<code>IO</code>操作的结果。</p>
<ul>
<li>使用<code>java.util.concurrent.Future</code>对象。</li>
<li>使用<code>java.nio.channels.CompletionHandler</code> 对象。</li>
</ul>
<h3 id="使用Future对象写入一个2000M的文件"><a href="#使用Future对象写入一个2000M的文件" class="headerlink" title="使用Future对象写入一个2000M的文件"></a>使用Future对象写入一个2000M的文件</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByAIO2</span><span class="params">()</span></span>{
    Path path = Paths.get(<span class="string">"E:\\tmp.dat"</span>);
    AsynchronousFileChannel afc = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        afc   = AsynchronousFileChannel.open(path, WRITE, CREATE);
        List&lt;Future&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();
        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);
        buf.clear();
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j++) {
            buf.put((<span class="keyword">byte</span>) <span class="number">1</span>);
        }
        buf.flip();
        buf.mark();
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i ++) {
            buf.reset();
            results.add(afc.write(buf, i * <span class="number">1024</span> *<span class="number">1024</span>));
        }
        <span class="keyword">for</span>(Future&lt;Integer&gt; future : results) {
            future.get();
        }
        System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">catch</span> (InterruptedException e) {
        e.printStackTrace();
    } <span class="keyword">catch</span> (ExecutionException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span>(afc != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                afc.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
写入时间:<span class="number">19732</span>ms
</code></pre>
<h3 id="使用CompletionHandler对象写入一个2000M的文件"><a href="#使用CompletionHandler对象写入一个2000M的文件" class="headerlink" title="使用CompletionHandler对象写入一个2000M的文件"></a>使用CompletionHandler对象写入一个2000M的文件</h3><p><code>Attachment</code>类，附带异步读写时，主线程的一些变量。</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> </span>{
    <span class="keyword">public</span> Path  path;
    <span class="keyword">public</span> ByteBuffer buffer;
    <span class="keyword">public</span> AsynchronousFileChannel asyncChannel;
    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>{
        System.out.println(count);
        <span class="keyword">if</span>(++ count &gt;= <span class="number">2000</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">this</span>.asyncChannel.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">WriteHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">Attachment</span>&gt; </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Attachment attachment)</span> </span>{
        System.out.format(<span class="string">"%s bytes written  to  %s%n"</span>, result,
                attachment.path.toAbsolutePath());
        attachment.close();
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Attachment attachment)</span> </span>{
        System.out.println(exc.getMessage());
        attachment.close();
    }
}
</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeAFileByAIO3</span><span class="params">()</span></span>{
    Path path = Paths.get(<span class="string">"E:\\tmp.dat"</span>);
    AsynchronousFileChannel afc = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        afc   = AsynchronousFileChannel.open(path, WRITE, CREATE);
        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);
        buf.clear();
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j++) {
            buf.put((<span class="keyword">byte</span>) <span class="number">1</span>);
        }
        buf.flip();
        buf.mark();
        Attachment attach  = <span class="keyword">new</span> Attachment();
        attach.asyncChannel = afc;
        attach.buffer = buf;
        attach.path = path;
        WriteHandler handler = <span class="keyword">new</span> WriteHandler();
        <span class="keyword">long</span> start = System.currentTimeMillis();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i ++) {
            buf.reset();
            afc.write(buf, i * <span class="number">1024</span> * <span class="number">1024</span>, attach, handler);
        }
        System.out.println(<span class="string">"写入时间:"</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">if</span>(afc != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                afc.close();
            } <span class="keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>上面代码可以看出，<code>CompletionHandler</code>方式如果在每次读取完成之后直接关闭<code>channel</code>，这会导致其他线程写入失败，所以这种操作需要做一些处理后才能关闭。<br>不管是<code>CompletionHandler</code>还是<code>Future</code>方式，到最后都会调用<code>sun.nio.ch.WindowsAsynchronousFileChannelImpl.WriteTask#run()</code>方法，该方法调用本地方法<code>openjdk\jdk\src\windows\native\sun\nio\ch\WindowsAsynchronousFileChannelImpl.c#Java_sun_nio_ch_WindowsAsynchronousFileChannelImpl_writeFile</code>,最后调用<code>windows</code>底层的<code>writeFile</code>函数。</p>
<pre><code class="java"><span class="comment">//组长overlapped数据结构，返回地址</span>
overlapped = ioCache.add(result);
<span class="comment">// 调用windows底层的writeFile函数</span>
n = writeFile(handle, address, rem, position, overlapped);
<span class="comment">//返回状态说明是异步执行</span>
<span class="keyword">if</span> (n == IOStatus.UNAVAILABLE) {
    <span class="comment">// I/O is pending</span>
    <span class="keyword">return</span>;
} <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Unexpected result: "</span> + n);
}
</code></pre>
<pre><code class="c++">JNIEXPORT jint JNICALL
Java_sun_nio_ch_WindowsAsynchronousFileChannelImpl_writeFile(JNIEnv* env, jclass <span class="keyword">this</span>,
    jlong handle, jlong address, jint len, jlong offset, jlong ov)
{
    BOOL res;

    OVERLAPPED* lpOverlapped = (OVERLAPPED*)jlong_to_ptr(ov);
    lpOverlapped-&gt;Offset = (DWORD)offset;
    lpOverlapped-&gt;OffsetHigh = (DWORD)((<span class="keyword">long</span>)(offset &gt;&gt; <span class="number">32</span>));
    lpOverlapped-&gt;hEvent = <span class="literal">NULL</span>;

    res = WriteFile((HANDLE)jlong_to_ptr(handle),
                   (LPVOID) jlong_to_ptr(address),
                   (DWORD)len,
                   <span class="literal">NULL</span>,
                   lpOverlapped);

    <span class="keyword">if</span> (res == <span class="number">0</span>) {
        <span class="keyword">int</span> error = GetLastError();
        <span class="keyword">if</span> (error == ERROR_IO_PENDING)
            <span class="keyword">return</span> IOS_UNAVAILABLE;
        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"WriteFile failed"</span>);
        <span class="keyword">return</span> IOS_THROWN;
    }

    <span class="keyword">return</span> IOS_UNAVAILABLE;
}
</code></pre>
<p><code>windows</code>底层的<code>writeFile</code>函数详解请参考<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365747%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">WriteFile function</a>,该函数最后一个参数<code>lpOverlapped</code>是异步实现的一个重要数据结构，该函数详解请参考<a href="http://blog.csdn.net/tgxallen/article/details/77428539" target="_blank" rel="noopener">windows IOCP完成端口原理详解
</a>。</p>
<h3 id="异步读文件"><a href="#异步读文件" class="headerlink" title="异步读文件"></a>异步读文件</h3><p>参考<a href="http://www.java2s.com/Tutorials/Java/Java_io/1050__Java_nio_Asynchronous.htm" target="_blank" rel="noopener">Java IO Tutorial - Java Asynchronous I/O</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>减少<code>IO</code>发生的次数可以提高文件读写的效率。具体操作是一次读取/写入多个字节。</li>
<li>在相同缓存大小的情况下<code>read(byte[])</code>比<code>BufferedInputStream</code>效率要高，虽然从源码上看二者产不多，但实际上<code>read(byte[])</code>要快很多，具体原因可能与<code>synchronized</code>关键字有关。</li>
<li><code>NIO</code>的文件读写效率比<code>read(byte[])</code>差不多，二者都是调用底层的<code>write</code>函数，但<code>NIO</code>提供了比较方便的API。</li>
<li><code>AIO</code>并没有加速<code>IO</code>处理速度，只是利用回调和通知机制改变了业务处理时机，使得具体逻辑可以不关注<code>IO</code>结果，只需在合理的时机添加回调即可。但是多线程的文件读写并没有比同步的读写快，原因不清楚。<code>windows</code>系统的异步<code>IO</code>是通过<code>IOCP</code>完成的。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><code>read(byte[])</code>比<code>BufferedInputStream</code>效率高具体是什么原因导致的。</li>
<li>多线程的文件读写并没有比同步的读写快，为什么？</li>
<li><code>windows</code>系统的<code>IOCP</code>是如何管理线程的，又是怎样通知怎样回调的？</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> I/O </category>
            
        </categories>
        
        
        <tags>
            
            <tag> I/O </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[五大IO模型]]></title>
      <url>/2018/02/07/%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对程序员而言，<code>I/O</code>操作是程序中最常见的操作之一。比如说磁盘文件的读写、数据的网络传输等等。程序=数据结构+算法，其中数据元素的获取就必须通过<code>I/O</code>操作来完成。在当今这个数据大爆炸时代，<code>I/O</code>问题尤其突出，很容易成为一个性能瓶颈。<br>然而很多程序员甚至是高级程序员对<code>I/O</code>操作只是停留在会用的阶段，遇到相应的业务场景只是去COPY一段代码，小型项目这样当然没问题，对于<code>I/O</code>密集型的项目，如果理解不深，有可能会造成严重的问题。实际工作中我也是这样，经常在网上找一段代码不去分析他的原理，从而走了不少弯路。作为<code>Java</code>程序员，深入的理解<code>I/O</code>操作很有必要，所以在这里做一个系统的整理。</p>
</blockquote>
<a id="more"></a>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（<code>kernel</code>），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为<strong>内核空间</strong>，一部分为<strong>用户空间</strong>。针对<code>linux</code>操作系统而言，将最高的1G字节（从虚拟地址<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址<code>0x00000000</code>到<code>0xBFFFFFFF</code>），供各个进程使用，称为用户空间。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在<code>CPU</code>上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新<code>PCB</code>信息。</li>
<li>把进程的<code>PCB</code>移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其<code>PCB</code>。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<p>注：总而言之就是很耗资源。</p>
<h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(<code>Block</code>)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得<code>CPU</code>），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用<code>CPU</code>资源的。<br>简单点说就是等别人完成事务后你才能继续你的工作。</p>
<h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（<code>File descriptor</code>）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于<code>UNIX</code>、<code>Linux</code>这样的操作系统</p>
<h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p>缓冲区及操作是所有<code>I/O</code>的基础，进程执行<code>I/O</code>操作，归结起来就是向操作系统发出请求，让它要么把缓冲区里的数据排干（写），要么把缓冲区填满（读）。如下图<br><img src="缓存IO图.jpg" alt="缓存 I/O"></p>
<p>缓存 <code>I/O</code> 的缺点：<br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作(先将数据准备到内核空间，再将数据拷贝到用户空间)，这些数据拷贝操作所带来的 <code>CPU</code> 以及内存开销是非常大的。</p>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><p>对于一次<code>IO</code>访问（以<code>read</code>举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个<code>read</code>操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (<code>Waiting for the data to be ready</code>)</li>
<li>将数据从内核拷贝到进程中 (<code>Copying the data from the kernel to the process</code>)</li>
</ol>
<p>根据这两个阶段，有下面5种<code>I/O</code>模型:</p>
<ul>
<li>阻塞 <code>I/O</code>（<code>blocking IO</code>）</li>
<li>非阻塞 <code>I/O</code>（<code>nonblocking IO</code>）</li>
<li><code>I/O</code> 多路复用（ <code>IO multiplexing</code>）</li>
<li>信号驱动 <code>I/O</code>（ <code>signal driven IO</code>）</li>
<li>异步 <code>I/O</code>（<code>asynchronous IO</code>）</li>
</ul>
<h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p><img src="阻塞式IO.png" alt="阻塞式 I/O"><br>当用户进程调用了<code>recvfrom</code>这个系统调用，<code>kernel</code>就开始了<code>IO</code>的第一个阶段：准备数据（对于网络<code>IO</code>来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的<code>UDP</code>包。这个时候<code>kernel</code>就要等待足够的数据到来，磁盘<code>I/O</code>的情况就是等待磁盘数据从磁盘上读取到内核态内存中）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当<code>kernel</code>一直等到数据准备好了，它就会将数据从<code>kernel</code>中拷贝到用户内存(出于系统安全,用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中)，然后<code>kernel</code>返回结果，用户进程才解除<code>block</code>的状态，重新运行起来。<br>所以，<code>blocking IO</code>的特点就是在<code>IO</code>执行的两个阶段都被<code>block</code>了。</p>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p><code>socket</code> 设置为 <code>NONBLOCK</code>（非阻塞）就是告诉内核，当所请求的 <code>I/O</code> 操作无法完成时，不要将进程睡眠，而是返回一个错误码(<code>EWOULDBLOCK</code>) ，这样请求就不会阻塞。<br><img src="非阻塞式IO.png" alt="非阻塞式 I/O"></p>
<p>当用户进程发出<code>read</code>操作时，如果<code>kernel</code>中的数据还没有准备好，那么它并不会<code>block</code>用户进程，而是立刻返回一个<code>error</code>。从用户进程角度讲 ，它发起一个<code>read</code>操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个<code>error</code>时，它就知道数据还没有准备好，于是它可以再次发送<code>read</code>操作。一旦<code>kernel</code>中的数据准备好了，并且又再次收到了用户进程的<code>system call</code>，那么它马上就将数据拷贝到了用户内存，然后返回。<br><code>I/O</code> 操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。整个<code>I/O</code> 请求的过程中，虽然用户线程每次发起 <code>I/O</code> 请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的 <code>CPU</code>的资源<br>所以，<code>nonblocking IO</code>的特点是用户进程需要不断的主动询问<code>kernel</code>数据好了没有。在数据拷贝阶段，用户进程还是阻塞的。<br>一般很少直接使用这种模型，而是在其他 <code>I/O</code> 模型中使用非阻塞 <code>I/O</code> 这一特性。这种方式对单个 <code>I/O</code> 请求意义不大,但给 <code>I/O</code> 多路复用铺平了道路。</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p><code>I/O</code> 多路复用会用到 <code>select</code> 或者 <code>poll</code> 函数，这两个函数也会使进程阻塞，但是和阻塞 <code>I/O</code> 所不同的的，这两个函数可以同时阻塞多个 <code>I/O</code> 操作。而且可以同时对多个读操作，多个写操作的 <code>I/O</code> 函数进行检测，直到有数据可读或可写时，才真正调用 <code>I/O</code> 操作函数。<br><img src="IO复用.png" alt="IO复用"></p>
<p>从流程上来看，使用 <code>select</code> 函数进行 <code>I/O</code> 请求和同步阻塞模型没有太大的区别，甚至还多了添加监视 <code>socket</code>，以及调用 <code>select</code> 函数的额外操作，效率更差。但是，使用 <code>select</code> 以后最大的优势是用户可以在一个线程内同时处理多个 <code>socket</code> 的 <code>I/O</code> 请求。用户可以注册多个 <code>socket</code>，然后不断地调用 <code>select</code> 读取被激活的 <code>socket</code>，即可达到在同一个线程内同时处理多个 <code>I/O</code> 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。其实多路复用是同步非阻塞模型的<code>Reactor</code>模式的实现。</p>
<h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>首先我们允许 <code>socket</code> 进行信号驱动 <code>I/O</code>,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 <code>SIGIO</code> 信号，可以在信号处理函数中调用 <code>I/O</code> 操作函数处理数据。<br><img src="信号驱动.png" alt="信号驱动"></p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="异步IO.png" alt="异步IO"><br>用户进程发起<code>read</code>操作之后，立刻就可以开始去做其它的事。而另一方面，从<code>kernel</code>的角度，当它受到一个<code>asynchronous read</code>之后，首先它会立刻返回，所以不会对用户进程产生任何<code>block</code>。然后，<code>kernel</code>会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<code>kernel</code>会给用户进程发送一个<code>signal</code>，告诉它<code>read</code>操作完成了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>BIO</code>方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高(服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。),并发局限于应用中，<code>JDK1.4</code>以前的唯一选择，但程序直观简单易理解。 </li>
<li><code>NIO</code>方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，<code>JDK1.4</code>开始支持。</li>
<li><code>AIO</code>方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用<code>OS</code>参与并发操作，编程比较复杂，<code>JDK7</code>开始支持。 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> I/O </category>
            
        </categories>
        
        
        <tags>
            
            <tag> I/O </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跳一跳辅助的java实现]]></title>
      <url>/2018/01/10/%E8%B7%B3%E4%B8%80%E8%B7%B3%E8%BE%85%E5%8A%A9%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近微信跳一跳小游戏在朋友圈着实火了一把，为了争第一，朋友圈的最高分一次一次刷新，随后好多人晒出了自己刷分攻略，有制作物理外挂的，有程序外挂的。作为程序员，特别动手能力比较强的程序员，这时候就闲不住了。<code>GitHub</code>上已经有<code>Python</code>版外挂<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">(https://github.com/wangshub/wechat_jump_game)</a>，这里我用<code>Java</code>实现。</p>
</blockquote>
<img src="/2018/01/10/跳一跳辅助的java实现/jump.gif" title="自动脚本跳一跳">
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>跳一跳辅助的原理特别简单，主要由以下几个步骤完成：</p>
<ul>
<li>量出小人底盘中心点的位置与下一跳中心点的距离（可以通过鼠标点击的方式测量或者图像分析的方式获得），因为每次跳跃的角度有一定规律，所以获取两点的横向距离也可以。</li>
<li>手动多跳几次，记录时间和距离，二者之间存在线性关系，即 <code>t=f(d)</code>，在坐标图中划出以上几点，求出关系函数。</li>
<li>根据距离和关系函数算出按压时间，通过<code>adb</code>发送按压命令。</li>
</ul>
<h1 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h1><h2 id="adb协议"><a href="#adb协议" class="headerlink" title="adb协议"></a><code>adb</code>协议</h2><p><code>Android Debug Bridge</code>是对所有连接到开发机器上的<code>android</code>真机和模拟器进行跟踪管理，实现了大量控制命令，方便<code>PC</code>端通过命令行或者助手类程序来控制<code>Android</code>设备。简而言之，是PC端和<code>Android</code>设备通信的中间桥。<br><code>adb</code>协议有很多实现方式，这里用的是<code>vidstige</code>的<code>java</code>实现:<a href="https://github.com/vidstige/jadb" target="_blank" rel="noopener">(https://github.com/vidstige/jadb)</a></p>
<h1 id="图像分析基础"><a href="#图像分析基础" class="headerlink" title="图像分析基础"></a>图像分析基础</h1><h1 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h1><h2 id="模拟按压的实现"><a href="#模拟按压的实现" class="headerlink" title="模拟按压的实现"></a>模拟按压的实现</h2><p>这里将模拟按压实现为一个<code>Server</code>，等待<code>client</code>的输入，可以是图像分析获取点距的自动输入，也可以是鼠标测量的手动输入。</p>
<pre><code class="java"><span class="keyword">package</span> jiges.github;

<span class="keyword">import</span> se.vidstige.jadb.JadbConnection;
<span class="keyword">import</span> se.vidstige.jadb.JadbDevice;
<span class="keyword">import</span> se.vidstige.jadb.JadbException;

<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.net.ServerSocket;
<span class="keyword">import</span> java.net.Socket;
<span class="keyword">import</span> java.text.DecimalFormat;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="comment">/**</span>
<span class="comment"> * 模拟按压服务</span>
<span class="comment"> * Created by ccr at 2018/1/3.</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PressServer</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{

        JadbConnection jadb = <span class="keyword">null</span>;
        DataInputStream reader = <span class="keyword">null</span>;
        DataOutputStream writer = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            jadb = <span class="keyword">new</span> JadbConnection();
            List&lt;JadbDevice&gt; devices = jadb.getDevices();
            JadbDevice device = devices.get(<span class="number">0</span>);
            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);
            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                System.out.print(<span class="string">"等待输入:"</span>);
                Socket client = serverSocket.accept();
                reader = <span class="keyword">new</span> DataInputStream(client.getInputStream());
                writer = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());
                String input = reader.readUTF();
                System.out.println(input);
                <span class="keyword">int</span> d = Integer.valueOf(input);
                <span class="comment">//计算按压时间</span>
                <span class="keyword">double</span> time = d * <span class="number">1.565</span>;
                DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"0"</span>);
                <span class="comment">//发送按压指令</span>
                device.executeShell(<span class="string">"input"</span>,<span class="string">"touchscreen"</span>,<span class="string">"swipe"</span>,<span class="string">"200"</span>,<span class="string">"200"</span>,<span class="string">"200"</span>,<span class="string">"200"</span>,String.valueOf(df.format(time)));
                <span class="comment">//睡眠一定时间后才返回，需要2s的时间完成跳跃动作</span>
                TimeUnit.MILLISECONDS.sleep((<span class="keyword">long</span>) time + <span class="number">2000</span>);
                writer.writeUTF(<span class="string">"OK"</span>);
            }

        } <span class="keyword">catch</span> (IOException | JadbException | InterruptedException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<h2 id="手动和自动的按压方式"><a href="#手动和自动的按压方式" class="headerlink" title="手动和自动的按压方式"></a>手动和自动的按压方式</h2><pre><code class="java"><span class="keyword">package</span> jiges.github;

<span class="keyword">import</span> jiges.github.picture.Picture;
<span class="keyword">import</span> se.vidstige.jadb.JadbConnection;
<span class="keyword">import</span> se.vidstige.jadb.JadbDevice;
<span class="keyword">import</span> se.vidstige.jadb.JadbException;

<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.net.Socket;
<span class="keyword">import</span> java.util.List;

<span class="comment">/**</span>
<span class="comment"> * Created by ccr at 2018/1/8.</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PressClient</span> </span>{

    <span class="comment">/**</span>
<span class="comment">     * 图片分析</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        JadbConnection jadb = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            jadb = <span class="keyword">new</span> JadbConnection();
            List&lt;JadbDevice&gt; devices = jadb.getDevices();
            <span class="keyword">if</span>(<span class="keyword">null</span> == devices || devices.isEmpty()) {
                System.out.println(<span class="string">"未找到设备."</span>);
                System.exit(<span class="number">0</span>);
            }
            JadbDevice device = devices.get(<span class="number">0</span>);
            Picture picture = <span class="keyword">new</span> Picture(device);
            <span class="keyword">while</span>(<span class="keyword">true</span>) {
                picture.loadPicture();
                sendCommand(picture.analyze());

            }

        } <span class="keyword">catch</span> (IOException | JadbException e) {
            e.printStackTrace();
        }
    }

    <span class="comment">/**</span>
<span class="comment">     * 手动输入距离</span>
<span class="comment">     */</span>
    <span class="comment">/*public static void main(String[] args) {</span>
<span class="comment">        BufferedReader br = null;</span>
<span class="comment">        try {</span>
<span class="comment">            while(true) {</span>
<span class="comment">                //等待键盘输入</span>
<span class="comment">                br = new BufferedReader(new InputStreamReader(System.in));</span>
<span class="comment">                System.out.print("请输入距离:");</span>
<span class="comment">                String input = br.readLine();</span>
<span class="comment">                if(null != input &amp;&amp; input.equals("quit")) {</span>
<span class="comment">                    System.exit(0);</span>
<span class="comment">                }</span>
<span class="comment">                sendCommand(Integer.valueOf(input));</span>
<span class="comment">            }</span>
<span class="comment">        } catch (IOException e) {</span>
<span class="comment">            e.printStackTrace();</span>
<span class="comment">        }</span>
<span class="comment">    }*/</span>


    <span class="comment">/**</span>
<span class="comment">     * 发送按压命令，可将Socket提出来，不需要每次都建立连接</span>
<span class="comment">     * <span class="doctag">@param</span> distance 距离</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendCommand</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>{
        Socket socket = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8899</span>);
            socket.setSoTimeout(<span class="number">10000</span>);
            DataOutputStream out = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());
            DataInputStream in = <span class="keyword">new</span> DataInputStream(socket.getInputStream());
            out.writeUTF(String.valueOf(distance));
            String res = in.readUTF();
            System.out.println(res);
        } <span class="keyword">catch</span> (IOException e1) {
            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) {
                <span class="keyword">try</span> {
                    socket.close();
                } <span class="keyword">catch</span> (IOException e2) {
                    socket = <span class="keyword">null</span>;
                }
            }
            e1.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) {
                <span class="keyword">try</span> {
                    socket.close();
                } <span class="keyword">catch</span> (IOException e1) {
                    socket = <span class="keyword">null</span>;
                }
            }
        }
    }
}
</code></pre>
<h2 id="图像分析和展示"><a href="#图像分析和展示" class="headerlink" title="图像分析和展示"></a>图像分析和展示</h2><pre><code class="java"><span class="keyword">package</span> jiges.github.picture;

<span class="keyword">import</span> jiges.github.PressClient;
<span class="keyword">import</span> se.vidstige.jadb.*;

<span class="keyword">import</span> javax.imageio.ImageIO;
<span class="keyword">import</span> java.awt.event.ActionEvent;
<span class="keyword">import</span> java.awt.event.ActionListener;
<span class="keyword">import</span> java.awt.image.BufferedImage;
<span class="keyword">import</span> java.io.*;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="comment">/**</span>
<span class="comment"> * 图片工具，截图，展示和图片计算</span>
<span class="comment"> * Created by ccr at 2018/1/3.</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Picture</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WIDTH = <span class="number">1080</span>;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HEIGHT = <span class="number">1920</span>;

    <span class="comment">//小人的RGB范围</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Rgb LITTLE_MAN_RGB_MIN = <span class="keyword">new</span> Rgb(<span class="number">43</span>,<span class="number">43</span>,<span class="number">70</span>);
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Rgb LITTLE_MAN_RGB_MAX = <span class="keyword">new</span> Rgb(<span class="number">60</span>,<span class="number">60</span>,<span class="number">108</span>);


    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LITTLE_MAN_WIDTH = <span class="number">60</span>;

    <span class="keyword">private</span> JadbDevice device;

    <span class="keyword">private</span> BufferedImage image;

    <span class="keyword">private</span> ImageViewer imageViewer;

    <span class="keyword">private</span> <span class="keyword">int</span> distance;

    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(JadbDevice device)</span> </span>{
        <span class="keyword">this</span>.device = device;
    }

    <span class="comment">//图片的展示</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initImageViewer</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>.imageViewer = <span class="keyword">new</span> ImageViewer(DEFAULT_WIDTH,DEFAULT_HEIGHT);
        <span class="keyword">this</span>.imageViewer.getRefreshBtn().addActionListener(<span class="keyword">new</span> ActionListener() {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>{
                loadPicture();
                imageViewer.setComputeRet(String.valueOf(analyze()));
            }
        });
        <span class="keyword">this</span>.imageViewer.getComputeBtn().addActionListener(<span class="keyword">new</span> ActionListener() {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>{
                imageViewer.setComputeRet(String.valueOf(analyze()));
            }
        });
        <span class="keyword">this</span>.imageViewer.getSendBtn().addActionListener(<span class="keyword">new</span> ActionListener() {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>{
                PressClient.sendCommand(distance);
            }
        });
        <span class="keyword">this</span>.imageViewer.setVisible(<span class="keyword">true</span>);
    }


    <span class="comment">/**</span>
<span class="comment">     * adb截屏，将图片加载到pc中进行分析</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPicture</span><span class="params">()</span></span>{
        ByteArrayOutputStream outputStream = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            device.executeShell(<span class="string">"mkdir"</span>,<span class="string">"/sdcard/screenshot/"</span>);
            device.executeShell(<span class="string">"/system/bin/screencap"</span>, <span class="string">"-p"</span>, <span class="string">"/sdcard/screenshot/screenshot.png"</span>);
            <span class="comment">//截图只是发送命令，手机需要一定时间需要完成截屏动作，直接拉去图片可能会报错</span>
            TimeUnit.SECONDS.sleep(<span class="number">2</span>);
            outputStream =  <span class="keyword">new</span> ByteArrayOutputStream();
            device.pull(<span class="keyword">new</span> RemoteFile(<span class="string">"/sdcard/screenshot/screenshot.png"</span>), outputStream);
            <span class="keyword">if</span>(outputStream.size() &gt; <span class="number">0</span>) {
                image = ImageIO.read(<span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray()));
                <span class="keyword">if</span>(<span class="keyword">null</span> != imageViewer)
                    imageViewer.refreshImage(image);
            }
        } <span class="keyword">catch</span> (IOException | JadbException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    <span class="comment">/**</span>
<span class="comment">     * 图片分析</span>
<span class="comment">     * 1、计算小人的位置，取x坐标。</span>
<span class="comment">     * 2、计算下一跳方块或圆盘的顶点位置，取x坐标。</span>
<span class="comment">     * 3、根据x坐标差计算按压时间</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">analyze</span><span class="params">()</span></span>{
        Point littleManPos = <span class="keyword">this</span>.computeLittleManPosition();
        Point nextPos = computeNextPosition(littleManPos);
        <span class="keyword">this</span>.distance = Math.abs(nextPos.getX() - littleManPos.getX());
        System.out.println(<span class="keyword">this</span>.distance);
        <span class="keyword">return</span> distance;
    }

    <span class="comment">/**</span>
<span class="comment">     * 计算小人的位置，算法：</span>
<span class="comment">     * 1、小人的位置总在屏幕一定位置出现，为了减少计算量，假设小人总是在屏幕的1/3到2/3的位置出现。</span>
<span class="comment">     * 2、给小人做横切线，底部最长横切线的中点即为小人的位置。</span>
<span class="comment">     * 3、根据颜色判断，找出这条线。</span>
<span class="comment">     * <span class="doctag">@return</span> 位置</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> Point <span class="title">computeLittleManPosition</span><span class="params">()</span></span>{
        <span class="keyword">int</span> imageWidth = image.getWidth();
        <span class="keyword">int</span> imageHeight  = image.getHeight();
        <span class="comment">//记录所有符合条件的线段</span>
        java.util.List&lt;Point[]&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="comment">//逐行扫描</span>
        <span class="keyword">for</span>(<span class="keyword">int</span> j = imageHeight / <span class="number">3</span>;j &lt; imageHeight * <span class="number">2</span> / <span class="number">3</span> ;j++) {
            Point[] line = <span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(<span class="number">0</span>,j),<span class="keyword">new</span> Point(<span class="number">0</span>,j)};
            <span class="keyword">for</span>(<span class="keyword">int</span> i = image.getMinX();i &lt; imageWidth ;i++) {
                <span class="comment">//该rgb大小4个字节，从高位到底位分别存放alpha，red，green，blue。</span>
                <span class="keyword">int</span> rgb = image.getRGB(i,j);
                <span class="comment">//如果颜色在小人颜色范围内，则记录首尾点</span>
                <span class="keyword">if</span>(<span class="keyword">new</span> Rgb((rgb &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span> ,(rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>,rgb &amp; <span class="number">0xff</span>).isBetween(LITTLE_MAN_RGB_MIN, LITTLE_MAN_RGB_MAX)) {
                    line[<span class="number">1</span>].setX(i);
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span>(line[<span class="number">1</span>].getX() &gt; line[<span class="number">0</span>].getX()) {
                        lines.add(<span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(line[<span class="number">0</span>].getX(),line[<span class="number">0</span>].getY()),<span class="keyword">new</span> Point(line[<span class="number">1</span>].getX(),line[<span class="number">1</span>].getY())});
                    }
                    line[<span class="number">0</span>].setX(i);
                    line[<span class="number">1</span>].setX(i);
                }
            }
        }
        <span class="comment">//找出最长的一条</span>
        Point[] line = <span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>),<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>)};
        <span class="keyword">for</span> (Point[] item : lines) {
            <span class="keyword">if</span>(Math.abs(item[<span class="number">1</span>].getX() - item[<span class="number">0</span>].getX()) &gt; Math.abs(line[<span class="number">1</span>].getX() - line[<span class="number">0</span>].getX())) {
                line = item;
            }
        }
        Point p = <span class="keyword">new</span> Point((line[<span class="number">0</span>].getX() + line[<span class="number">1</span>].getX()) / <span class="number">2</span>,(line[<span class="number">0</span>].getY() + line[<span class="number">1</span>].getY()) / <span class="number">2</span>);
        <span class="keyword">if</span>(<span class="keyword">null</span> != imageViewer)
            imageViewer.showPoint(p,image);
        <span class="comment">//返回中点</span>
        <span class="keyword">return</span> p;
    }

    <span class="comment">/**</span>
<span class="comment">     * 找出小人下一跳的位置</span>
<span class="comment">     * 1、下一跳的方块或圆块的位置也总是出现在屏幕的1/3到2/3的位置。</span>
<span class="comment">     * 2、根据底色跟方块的色差，找到方块或者圆盘的顶点。</span>
<span class="comment">     * 3、可以根据顶点的x坐标和小人的x坐标算出按压时间</span>
<span class="comment">     * <span class="doctag">@param</span> littleMan 小人的位置，为了解决小人的高度超过方块的高度引起的BUG</span>
<span class="comment">     * <span class="doctag">@return</span> 位置</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> Point <span class="title">computeNextPosition</span><span class="params">(Point littleMan)</span></span>{
        <span class="keyword">int</span> imageWidth = image.getWidth();
        <span class="keyword">int</span> imageHeight  = image.getHeight();
        Rgb bgRgb1 = <span class="keyword">null</span>,bgRgb2 = <span class="keyword">null</span>;
        Point point = <span class="keyword">null</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j = imageHeight / <span class="number">3</span>;j &lt; imageHeight * <span class="number">2</span> / <span class="number">3</span> ;j++) {
            <span class="comment">//顶点有可能不是一个点，而是一个小线段</span>
            Point[] line = <span class="keyword">new</span> Point[]{<span class="keyword">new</span> Point(<span class="number">0</span>,j),<span class="keyword">new</span> Point(<span class="number">0</span>,j)};

            <span class="keyword">for</span>(<span class="keyword">int</span> i = image.getMinX();i &lt; imageWidth ;i++) {
                <span class="comment">//解决小人的高度超过方块的高度引起的BUG</span>
                <span class="comment">//以小人的x坐标为终点，左右LITTLE_MAN_WIDTH像素的位置不扫描</span>
                <span class="keyword">if</span>(i &gt; littleMan.getX() - LITTLE_MAN_WIDTH &amp;&amp; i &lt; littleMan.getX() + LITTLE_MAN_WIDTH) {
                    <span class="keyword">continue</span>;
                }
                <span class="comment">//该rgb大小4个字节，从高位到底位分别存放alpha，red，green，blue。</span>
                <span class="keyword">int</span> rgb = image.getRGB(i,j);
                <span class="comment">//记录底色的rgb值,底色并不是纯色，所以底色是一个范围，设范围在20以内</span>
                <span class="keyword">if</span>(i == image.getMinX()) {
                    bgRgb1 = <span class="keyword">new</span> Rgb(((rgb &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) - <span class="number">10</span> ,((rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) - <span class="number">10</span>,(rgb &amp; <span class="number">0xff</span>) - <span class="number">10</span>);
                    bgRgb2 = <span class="keyword">new</span> Rgb(((rgb &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + <span class="number">10</span> ,((rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + <span class="number">10</span>,(rgb &amp; <span class="number">0xff</span>) + <span class="number">10</span>);
                }
                <span class="comment">//如果颜色在小人颜色范围内，则记录首尾点</span>
                <span class="keyword">if</span>(!<span class="keyword">new</span> Rgb((rgb &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span> ,(rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>,rgb &amp; <span class="number">0xff</span>).isBetween(bgRgb1,bgRgb2)) {
                    <span class="comment">//解决小人高于方块时的bug</span>
                    line[<span class="number">1</span>].setX(i);
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span>(line[<span class="number">1</span>].getX() &gt; line[<span class="number">0</span>].getX()) {
                        <span class="keyword">break</span>;
                    }
                    line[<span class="number">0</span>].setX(i);
                    line[<span class="number">1</span>].setX(i);
                }
            }
            <span class="keyword">if</span>(line[<span class="number">1</span>].getX() &gt; line[<span class="number">0</span>].getX()) {
                point = <span class="keyword">new</span> Point((line[<span class="number">0</span>].getX() + line[<span class="number">1</span>].getX()) / <span class="number">2</span>,(line[<span class="number">0</span>].getY() + line[<span class="number">1</span>].getY()) / <span class="number">2</span>);
                <span class="keyword">break</span>;
            }
        }
        <span class="comment">//标记绿色</span>
        <span class="keyword">if</span>(<span class="keyword">null</span> != imageViewer)
            imageViewer.showPoint(point,image);
        <span class="keyword">return</span> point;
    }

}
</code></pre>
<h3 id="截图并读取图片"><a href="#截图并读取图片" class="headerlink" title="截图并读取图片"></a>截图并读取图片</h3><p>图像获取是由<code>adb</code>发送截图命令，再将截图读取到内存中进行分析。期间遇到获取图片偶尔失败的问题，是因为截图命令发送后，<code>Android</code>设备要进行截图操作，截图操作和图片拉取是异步的，<code>adb</code>并未提供回调，所以导致拉取图片失败。读取图片是通过<code>adb``sync</code>模式实现的。</p>
<h3 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h3><p>图片分析的原理已经写在注释里，有几个地方要注意下。<br>计算小人底座中心点是根据颜色范围去确定的，在处理有污水井盖的圆块时，有“小人”以外的区域颜色和小人的颜色相同（如下图），这里的处理方法是，取颜色范围的横切线，收集到的所有横切线中，最长的那条线的中点就是小人的位置。<br><img src="小人.png" alt="小人.png"><br>下一跳计算也是做横切线，第一次遇到与背景色不同的线段即为顶点线段，其中点就是顶点，但在扫描时，小人有时候会高过下一跳方块，这导致下一跳的顶点落在小人的头顶上，这里的做法是，以小人中心位置向左右各60像素的区域不进行扫描。<br><img src="找点.png" alt="找点.png"></p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>由于各个手机不同，按压系数，扫描颜色的范围，屏幕宽度等各不相同，可以慢慢调节。</p>
<ul>
<li>安装<code>UniversalAdbDriver</code>,即<code>adb</code>驱动</li>
<li>先运行<code>PressServer</code>。</li>
<li>在选择手动或者自动的方式启动<code>PressClient</code>.运行<code>ImageView</code>可以加载图片手动取点。</li>
<li>源码位置(<a href="https://github.com/jiges/weixin-jump" target="_blank" rel="noopener">https://github.com/jiges/weixin-jump</a>)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM启动流程(源码分析)]]></title>
      <url>/2017/12/15/JVM%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<img src="/2017/12/15/JVM启动流程-源码分析/积累.jpg" title="不要小看那一丢丢的知识，一天天的积累，量变终将质变">
<a id="more"></a>
<blockquote>
<p>众所周知，<code>Java</code>程序的入口是在<code>main</code>方法中，然而在执行<code>main</code>方法之前，虚拟机是如何启动的？是如何找到<code>main</code>方法的？又是如何将参数传进来的？</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>java</code>程序员都知道，是通过<code>java</code>命令来运行程序的，运行程序时可以附加一些参数。具体的参数可以参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">【Java平台标准版工具参考】</a>。<code>java</code>命令标准的命令格式是：<code>java [options] classname [args]</code> 或者 <code>java [options] -jar filename [args]</code><br>用以下示例程序来调试<code>JVM</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动命令：</span></span><br><span class="line"><span class="comment">//java -d64 -server -Xss512k -cp "/home/ccr/jvm/javatest/" HelloJNI hello</span></span><br></pre></td></tr></table></figure></p>
<h1 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h1><p><code>JVM</code>的启动流程，可以分为以下几步：</p>
<ul>
<li><code>JVM</code>运行环境的设置和检查。</li>
<li>通过<code>CreateExecutionEnvironment</code>函数查找<code>JAVA_DLL</code>动态库是否存在，能不能访问。并设置一些变量。</li>
<li>加载动态库，将动态库中的一些函数链接至本地变量。</li>
<li>解析<code>[options]</code>和<code>[args]</code>参数。</li>
<li>新建线程初始化虚拟机。</li>
<li>加载并执行主类。</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>整个过程的入口是<code>/home/ccr/jvm/openjdk/jdk/src/share/bin/main.c</code>文件中的<code>main</code>函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> margc;</span><br><span class="line">    <span class="keyword">char</span>** margv;</span><br><span class="line">    <span class="keyword">const</span> jboolean const_javaw = <span class="number">0</span>;<span class="comment">//是否以javaw的方式启动</span></span><br><span class="line">    margc = argc;<span class="comment">//参数格式</span></span><br><span class="line">    margv = argv;<span class="comment">//接收命令行参数</span></span><br><span class="line">    <span class="keyword">return</span> JLI_Launch(margc, margv,</span><br><span class="line">			<span class="keyword">sizeof</span>(const_jargs) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), <span class="comment">// 1</span></span><br><span class="line">			const_jargs, <span class="comment">//0x0</span></span><br><span class="line">			<span class="keyword">sizeof</span>(const_appclasspath) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), <span class="comment">// 1</span></span><br><span class="line">			const_appclasspath,  <span class="comment">//0x0</span></span><br><span class="line">			FULL_VERSION, <span class="comment">// 1.8.0-internal-debug-ccr_2017_11_08_15_43-b00</span></span><br><span class="line">			DOT_VERSION, <span class="comment">// "1.8"</span></span><br><span class="line">			(const_progname != <span class="literal">NULL</span>) ? const_progname : *margv,  <span class="comment">//const_progname=java</span></span><br><span class="line">			(const_launcher != <span class="literal">NULL</span>) ? const_launcher : *margv, <span class="comment">//const_launcher = openjdk</span></span><br><span class="line">			(const_jargs != <span class="literal">NULL</span>) ? JNI_TRUE : JNI_FALSE, <span class="comment">//const_jargs = 0x0</span></span><br><span class="line">			const_cpwildcard, const_javaw, const_ergo_class); </span><br><span class="line">			<span class="comment">// const_cpwildcard = 1 '\\001'  const_javaw = 0  const_ergo_class = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>JLI_Launch</code>函数定义在<code>/home/ccr/jvm/openjdk/jdk/src/share/bin/java.c</code>文件中。该函数是<code>jvm</code>启动的前半部分，加载动态库。解析参数。</p>
<pre><code class="c++"><span class="function"><span class="keyword">int</span> <span class="title">JLI_Launch</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">int</span> jargc, <span class="keyword">const</span> <span class="keyword">char</span>** jargv,          <span class="comment">/* java args */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">int</span> appclassc, <span class="keyword">const</span> <span class="keyword">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span>* pname,                      <span class="comment">/* program name */</span></span></span>
<span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span>
<span class="function"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span>
<span class="function"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard*/</span></span></span>
<span class="function"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span>
<span class="function"><span class="params">        jint ergo                               <span class="comment">/* ergonomics class policy */</span></span></span>
<span class="function"><span class="params">)</span></span>
<span class="function"></span>{
    <span class="comment">//enum LaunchMode {               // cf. sun.launcher.LauncherHelper</span>
    <span class="comment">//LM_UNKNOWN = 0,</span>
    <span class="comment">//LM_CLASS,</span>
    <span class="comment">//LM_JAR</span>
    <span class="comment">//};</span>
    <span class="comment">//启动模式，jar启动，还是main class 启动</span>
    <span class="keyword">int</span> mode = LM_UNKNOWN;
    <span class="comment">//存储启动类类名</span>
    <span class="keyword">char</span> *what = <span class="literal">NULL</span>;
    <span class="comment">//存储class path</span>
    <span class="keyword">char</span> *cpath = <span class="number">0</span>;
    <span class="comment">//主类引用</span>
    <span class="keyword">char</span> *main_class = <span class="literal">NULL</span>;
    <span class="keyword">int</span> ret;
    <span class="comment">//加载JAVA_DLL时，将一些函数链接到此变量中</span>
    InvocationFunctions ifn;
    jlong start, end;
    <span class="comment">// JAVA_DLL动态库路径</span>
    <span class="keyword">char</span> jvmpath[MAXPATHLEN];
    <span class="comment">// jre路径</span>
    <span class="keyword">char</span> jrepath[MAXPATHLEN];
    <span class="comment">// jvm.cfg 文件路径</span>
    <span class="keyword">char</span> jvmcfg[MAXPATHLEN];

    _fVersion = fullversion;
    _dVersion = dotversion;
    _launcher_name = lname;
    _program_name = pname;
    _is_java_args = javaargs;
    _wc_enabled = cpwildcard;
    _ergo_policy = ergo;

    <span class="comment">//根据环境变量中的“_JAVA_LAUNCHER_DEBUG”参数来设置是否打印调试信息</span>
    <span class="comment">//_launcher_debug = false</span>
    InitLauncher(javaw);
    <span class="comment">//打印一些调试信息</span>
    DumpState();
    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {<span class="comment">//判断_launcher_debug变量</span>
        <span class="keyword">int</span> i;
        <span class="built_in">printf</span>(<span class="string">"Command line args:\n"</span>);
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) {
            <span class="built_in">printf</span>(<span class="string">"argv[%d] = %s\n"</span>, i, argv[i]);
        }
        AddOption(<span class="string">"-Dsun.java.launcher.diag=true"</span>, <span class="literal">NULL</span>);
    }

    <span class="comment">/*</span>
<span class="comment">     * Make sure the specified version of the JRE is running.</span>
<span class="comment">     *</span>
<span class="comment">     * There are three things to note about the SelectVersion() routine:</span>
<span class="comment">     *  1) If the version running isn't correct, this routine doesn't</span>
<span class="comment">     *     return (either the correct version has been exec'd or an error</span>
<span class="comment">     *     was issued).</span>
<span class="comment">     *  2) Argc and Argv in this scope are *not* altered by this routine.</span>
<span class="comment">     *     It is the responsibility of subsequent code to ignore the</span>
<span class="comment">     *     arguments handled by this routine.</span>
<span class="comment">     *  3) As a side-effect, the variable "main_class" is guaranteed to</span>
<span class="comment">     *     be set (if it should ever be set).  This isn't exactly the</span>
<span class="comment">     *     poster child for structured programming, but it is a small</span>
<span class="comment">     *     price to pay for not processing a jar file operand twice.</span>
<span class="comment">     *     (Note: This side effect has been disabled.  See comment on</span>
<span class="comment">     *     bugid 5030265 below.)</span>
<span class="comment">     */</span>
     <span class="comment">//需要指定版本的jre才能运行，通过命令行“-version:”命令，或者读取jar文件的mainfest文件</span>
     <span class="comment">//查看链接详情</span>
    SelectVersion(argc, argv, &amp;main_class);

    <span class="comment">//准备环境，搜索jrepath和jvmpath，具体实现在下面找</span>
    CreateExecutionEnvironment(&amp;argc, &amp;argv,
                               jrepath, <span class="keyword">sizeof</span>(jrepath),
                               jvmpath, <span class="keyword">sizeof</span>(jvmpath),
                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));
    <span class="comment">//动态链接库中的一些函数</span>
    <span class="comment">//创建虚拟机</span>
    ifn.CreateJavaVM = <span class="number">0</span>;
    <span class="comment">//获取默认初始化参数</span>
    ifn.GetDefaultJavaVMInitArgs = <span class="number">0</span>;

    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {
        start = CounterGet();
    }

    <span class="comment">//加载JAVA_DLL到内存，并将动态库中的函数链接至ifn.CreateJavaVM，ifn.CreateJavaVM，ifn.GetCreatedJavaVMs</span>
    <span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) {
        <span class="keyword">return</span>(<span class="number">6</span>);
    }

    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {
        end   = CounterGet();
    }

    JLI_TraceLauncher(<span class="string">"%ld micro seconds to LoadJavaVM\n"</span>,
             (<span class="keyword">long</span>)(jint)Counter2Micros(end-start));

    ++argv;
    --argc;

    <span class="keyword">if</span> (IsJavaArgs()) {
        <span class="comment">/* Preprocess wrapper arguments */</span>
        TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv);
        <span class="keyword">if</span> (!AddApplicationOptions(appclassc, appclassv)) {
            <span class="keyword">return</span>(<span class="number">1</span>);
        }
    } <span class="keyword">else</span> {
        <span class="comment">/* Set default CLASSPATH */</span>
        cpath = getenv(<span class="string">"CLASSPATH"</span>);
        <span class="keyword">if</span> (cpath == <span class="literal">NULL</span>) {
            cpath = <span class="string">"."</span>;
        }
        <span class="comment">//设置CLASSPATH</span>
        <span class="comment">//调用AddOption函数 将"-Djava.class.path=."字符串插入到JavaVMOption *options变量中</span>
        SetClassPath(cpath);
    }

    <span class="comment">/* Parse command line options; if the return value of</span>
<span class="comment">     * ParseArguments is false, the program should exit.</span>
<span class="comment">     */</span>
     <span class="comment">//解析所有option参数，并将其存到JavaVMOption *options变量中</span>
    <span class="keyword">if</span> (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath))
    {
        <span class="keyword">return</span>(ret);
    }

    <span class="comment">/* Override class path if -jar flag was specified */</span>
    <span class="comment">//-jar模式</span>
    <span class="keyword">if</span> (mode == LM_JAR) {
        SetClassPath(what);     <span class="comment">/* Override class path */</span>
    }

    <span class="comment">/* set the -Dsun.java.command pseudo property */</span>
    <span class="comment">//设置用来向java main方法暴露类名和参数，或者为java main存储方法名和参数</span>
    <span class="comment">//"-Dsun.java.command=HelloJNI hello"</span>
    SetJavaCommandLineProp(what, argc, argv);

    <span class="comment">/* Set the -Dsun.java.launcher pseudo property */</span>
    SetJavaLauncherProp();

    <span class="comment">/* set the -Dsun.java.launcher.* platform properties */</span>
    SetJavaLauncherPlatformProps();

    <span class="comment">//处理splash screen，开启新线程去初始化JVM</span>
    <span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
}
</code></pre>
<h2 id="环境准备动态库查找"><a href="#环境准备动态库查找" class="headerlink" title="环境准备动态库查找"></a>环境准备动态库查找</h2><p>准备环境，搜索<code>jrepath</code>和<code>jvmpath</code>的实现在<code>/home/ccr/jvm/openjdk/jdk/src/solaris/bin/java_md_solinux.c</code>文件中，该函数做了一些参数的检查，如<code>-d32</code>和<code>-d64</code>，如果和平台支持的数据模型不符，就会退出。然后通过<code>GetJREPath</code>函数，获取<code>JRE</code>路径，在读取<code>jvm.cfg</code>文件。改文件记录了<code>jvm</code>以何种类型启动(<code>-server</code>、<code>-client</code>等)，<code>-Server VM</code>启动慢，但是一旦运行起来后，性能将会有很大的提升。<code>-Client VM</code>启动快，运行相对较慢。文件记录的默认是<code>-server</code>类型。然后在获取<code>JAVA_DLL</code>的路径，在<code>Linux</code>上表现为<code>libjava.so</code>路径,在<code>windows</code>上是<code>jvm.dll</code>路径。另外该函数还检查了<code>LD_LIBRARY_PATH</code>环境变量，用户也可以通过这个环境变量来指定动态库文件。</p>
<pre><code class="c++"><span class="function"><span class="keyword">void</span> <span class="title">CreateExecutionEnvironment</span><span class="params">(<span class="keyword">int</span> *pargc, <span class="keyword">char</span> ***pargv,</span></span>
<span class="function"><span class="params">                           <span class="keyword">char</span> jrepath[], jint so_jrepath,</span></span>
<span class="function"><span class="params">                           <span class="keyword">char</span> jvmpath[], jint so_jvmpath,</span></span>
<span class="function"><span class="params">                           <span class="keyword">char</span> jvmcfg[],  jint so_jvmcfg)</span></span>{
    <span class="comment">//通过Linux的“/proc/self/exe”机制读取进程可执行文件（java）的绝对路径并将其塞进execname变量</span>
    <span class="comment">//“/home/ccr/jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java”</span>
    SetExecname(*pargv); 
    {        
        <span class="keyword">char</span> *arch        = (<span class="keyword">char</span> *)GetArchPath( ( <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)) ); <span class="comment">//获取系统的属性  amd64</span>
        <span class="keyword">char</span> * jvmtype    = <span class="literal">NULL</span>;
        <span class="keyword">int</span>  argc         = *pargc;
        <span class="keyword">char</span> **argv       = *pargv; <span class="comment">//命令行参数</span>
        <span class="keyword">int</span> running       = ( <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)); <span class="comment">// 64</span>

        <span class="keyword">int</span> wanted        = running;      <span class="comment">/* What data mode is being</span>
<span class="comment">                                           asked for? Current model is</span>
<span class="comment">                                           fine unless another model</span>
<span class="comment">                                           is asked for */</span>
        jboolean mustsetenv = <span class="number">0</span>;
        <span class="keyword">char</span> *runpath     = ((<span class="keyword">void</span> *)<span class="number">0</span>); <span class="comment">/* existing effective LD_LIBRARY_PATH setting */</span>
        <span class="keyword">char</span>* new_runpath = ((<span class="keyword">void</span> *)<span class="number">0</span>); <span class="comment">/* desired new LD_LIBRARY_PATH string */</span>
        <span class="keyword">char</span>* newpath     = ((<span class="keyword">void</span> *)<span class="number">0</span>); <span class="comment">/* path on new LD_LIBRARY_PATH */</span>
        <span class="keyword">char</span>* lastslash   = ((<span class="keyword">void</span> *)<span class="number">0</span>);
        <span class="keyword">char</span>** newenvp    = ((<span class="keyword">void</span> *)<span class="number">0</span>); <span class="comment">/* current environment */</span>

        <span class="keyword">char</span>** newargv    = ((<span class="keyword">void</span> *)<span class="number">0</span>);
        <span class="keyword">int</span>    newargc    = <span class="number">0</span>;


      <span class="comment">/*</span>
<span class="comment">       * Starting in 1.5, all unix platforms accept the -d32 and -d64</span>
<span class="comment">       * options.  On platforms where only one data-model is supported</span>
<span class="comment">       * (e.g. ia-64 Linux), using the flag for the other data model is</span>
<span class="comment">       * an error and will terminate the program.</span>
<span class="comment">       */</span>
       <span class="comment">//从1.5版本开始，所有Unix平台接收-d32和-d64操作，一种平台只能支持一种数据模型，用另外一种就会报错</span>
       <span class="comment">//这一整段代码目的是：看看命令行参数中有没有-d32和-d64，有就记录下来，然后删除这个参数</span>
       { <span class="comment">/* open new scope to declare local variables */</span>
        <span class="keyword">int</span> i;

        newargv = (<span class="keyword">char</span> **)JLI_MemAlloc((argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));
        newargv[newargc++] = argv[<span class="number">0</span>];

        <span class="comment">/* scan for data model arguments and remove from argument list;</span>
<span class="comment">           last occurrence determines desired data model */</span>
        <span class="comment">//扫描所有参数，删除数据模型的参数。strcmp是字符串比较</span>
        <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; argc; i++) {

          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-J-d64"</span> )) == <span class="number">0</span> || <span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-d64"</span> )) == <span class="number">0</span>) {
            wanted = <span class="number">64</span>;
            <span class="keyword">continue</span>;
          }
          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-J-d32"</span> )) == <span class="number">0</span> || <span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-d32"</span> )) == <span class="number">0</span>) {
            wanted = <span class="number">32</span>;
            <span class="keyword">continue</span>;
          }
          newargv[newargc++] = argv[i];
          <span class="comment">//false，判断_is_java_args变量，JLI_Launch中初始化，由main传入</span>
          <span class="keyword">if</span> (IsJavaArgs()) {
            <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) <span class="keyword">continue</span>;
          } <span class="keyword">else</span> {
            <span class="comment">//java 标准参数格式java [ options ] classname [ args ] 或者 java [ options ] -jar 文件名 [ args ]</span>
            <span class="comment">//-classpath或-cp出现说明options结束，剩下的是类名和参数</span>
            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-classpath"</span> )) == <span class="number">0</span> || <span class="built_in">strcmp</span>(( argv[i] ), ( <span class="string">"-cp"</span> )) == <span class="number">0</span>) {
              i++;
              <span class="keyword">if</span> (i &gt;= argc) <span class="keyword">break</span>;
              newargv[newargc++] = argv[i];
              <span class="keyword">continue</span>;
            }
            <span class="comment">//options结束的标志，除了-cp 后面的参数</span>
            <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) { i++; <span class="keyword">break</span>; }
          }
        }

        <span class="comment">/* copy rest of args [i .. argc) */</span>
        <span class="comment">//拷贝剩余的参数</span>
        <span class="keyword">while</span> (i &lt; argc) {
          newargv[newargc++] = argv[i++];
        }    
        newargv[newargc] = <span class="literal">NULL</span>;

        <span class="comment">/*</span>
<span class="comment">         * newargv has all proper arguments here</span>
<span class="comment">         */</span>

        argc = newargc;
        argv = newargv;
      }        
       <span class="comment">/* If the data model is not changing, it is an error if the</span>
<span class="comment">         jvmpath does not exist */</span>
      <span class="keyword">if</span> (wanted == running) {
        <span class="comment">/* Find out where the JRE is that we will be using. */</span>
        <span class="comment">//获取JRE路径</span>
        <span class="keyword">if</span> (!GetJREPath(jrepath, so_jrepath, arch, <span class="number">0</span>) ) {
          JLI_ReportErrorMessage(<span class="string">"Error: Could not find Java SE Runtime Environment."</span>);
          <span class="built_in">exit</span>(<span class="number">2</span>);
        }
        <span class="comment">//jvm.cfg 路径  "/home/ccr/jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/jvm.cfg"</span>
        <span class="built_in">snprintf</span>(jvmcfg, so_jvmcfg, <span class="string">"%s%slib%s%s%sjvm.cfg"</span>,
                     jrepath, <span class="string">"/"</span>, <span class="string">"/"</span>,  arch, <span class="string">"/"</span>);
        <span class="comment">/* Find the specified JVM type */</span>
        <span class="comment">//读取jvm.cfg的配置文件，填充knownVMs变量，knownVMs数据结构在下面</span>
        <span class="keyword">if</span> (ReadKnownVMs(jvmcfg, <span class="number">0</span>) &lt; <span class="number">1</span>) {
          JLI_ReportErrorMessage(<span class="string">"Error: no known VMs. (check for corrupt jvm.cfg file)"</span>);
          <span class="built_in">exit</span>(<span class="number">1</span>);
        }

        jvmpath[<span class="number">0</span>] = <span class="string">'\0'</span>;
        <span class="comment">//检查JVM的类型，如果命令行没有给出类型（指的是 -client 或者 -server参数），</span>
        <span class="comment">//则会检查"JDK_ALTERNATE_VM"环境变量或者命令行'-XXaltjvm='参数。</span>
        <span class="comment">//如果都没有指定，则使用默认的类型（定义在jvm.cfg配置文件中）</span>
        jvmtype = CheckJvmType(pargc, pargv, <span class="number">0</span>);
        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( jvmtype ), ( <span class="string">"ERROR"</span> )) == <span class="number">0</span>) {
            JLI_ReportErrorMessage(<span class="string">"Error: could not determine JVM type."</span>);
            <span class="built_in">exit</span>(<span class="number">4</span>);
        }

        <span class="comment">//获取JAVA_DLL路径  "/home/ccr/jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/libjvm.so"</span>
        <span class="keyword">if</span> (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath, arch, <span class="number">0</span> )) {
          JLI_ReportErrorMessage(<span class="string">"Error: missing `%s' JVM at `%s'.\nPlease install or use the JRE or JDK that contains these missing components."</span>, jvmtype, jvmpath);
          <span class="built_in">exit</span>(<span class="number">4</span>);
        }
        <span class="comment">/*</span>
<span class="comment">         * we seem to have everything we need, so without further ado</span>
<span class="comment">         * we return back, otherwise proceed to set the environment.</span>
<span class="comment">         */</span>
        <span class="comment">//测试所有需要的环境变量是否被设置，主要检查"LD_LIBRARY_PATH"环境变量，</span>
        <span class="comment">//LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径</span>
        <span class="comment">//实现中的一句注释  no environment variable is a good environment variable</span>
        mustsetenv = RequiresSetenv(wanted, jvmpath);
        JLI_TraceLauncher(<span class="string">"mustsetenv: %s\n"</span>, mustsetenv ? <span class="string">"TRUE"</span> : <span class="string">"FALSE"</span>);

        <span class="keyword">if</span> (mustsetenv == <span class="number">0</span>) {
            JLI_MemFree(newargv);
            <span class="keyword">return</span>;
        }
      } <span class="keyword">else</span> {  <span class="comment">/* do the same speculatively or exit */</span>
        JLI_ReportErrorMessage(<span class="string">"Error: This Java instance does not support a %d-bit JVM.\nPlease install the desired version."</span>, wanted);
        <span class="built_in">exit</span>(<span class="number">1</span>);
      }
      <span class="comment">//设置了LD_LIBRARY_PATH环境变量，并且目录中存在lib/$LIBARCH/{server,client}/libjvm.so文件</span>
      <span class="keyword">if</span> (mustsetenv) {
            ......
        }

        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
}
</code></pre>
<p>函数<code>GetJREPath</code>使用来获取<code>JRE</code>路径的。在<code>CreateExecutionEnvironment</code>函数中，通过调用<code>SetExecname</code>函数将可执行文件的绝对路径塞进<code>execname</code>变量，比如这里是<code>jdkpath/jdk/bin/java</code>。经过简单处理后得到<code>jdkpath/jdk</code>。该函数还检查了链接库的访问权限。</p>
<pre><code class="c++"><span class="comment">/*</span>
<span class="comment"> * Find path to JRE based on .exe's location or registry settings.</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">static</span> jboolean <span class="title">GetJREPath</span><span class="params">(<span class="keyword">char</span> *path, jint pathsize, <span class="keyword">const</span> <span class="keyword">char</span> * arch, jboolean speculative)</span></span>
<span class="function"></span>{
    <span class="keyword">char</span> libjava[<span class="number">4096</span>];
    <span class="comment">//找到JDK路径并传到path变量中</span>
    <span class="keyword">if</span> (GetApplicationHome(path, pathsize)) {
        <span class="comment">/* Is JRE co-located with the application? */</span>
        <span class="comment">// /home/ccr/jvm/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/libjava.so</span>
        <span class="built_in">snprintf</span>(libjava, <span class="keyword">sizeof</span>(libjava), <span class="string">"%s/lib/%s/"</span> <span class="string">"libjava.so"</span>, path, arch);
        <span class="comment">//是否可访问</span>
        <span class="keyword">if</span> (access(libjava, <span class="number">0</span>) == <span class="number">0</span>) {
            JLI_TraceLauncher(<span class="string">"JRE path is %s\n"</span>, path);
            <span class="keyword">return</span> <span class="number">1</span>;
        }

        <span class="comment">/* Does the app ship a private JRE in &lt;apphome&gt;/jre directory? */</span>
        <span class="built_in">snprintf</span>(libjava, <span class="keyword">sizeof</span>(libjava), <span class="string">"%s/jre/lib/%s/"</span> <span class="string">"libjava.so"</span>, path, arch);
        <span class="keyword">if</span> (access(libjava, <span class="number">0</span>) == <span class="number">0</span>) {
            <span class="built_in">strcat</span>(( path ), ( <span class="string">"/jre"</span> ));
            JLI_TraceLauncher(<span class="string">"JRE path is %s\n"</span>, path);
            <span class="keyword">return</span> <span class="number">1</span>;
        }
    }

    <span class="keyword">if</span> (!speculative)
      JLI_ReportErrorMessage(<span class="string">"Error: could not find "</span> <span class="string">"libjava.so"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
<span class="comment">/*</span>
<span class="comment"> * If app is "/foo/bin/javac", or "/foo/bin/sparcv9/javac" then put</span>
<span class="comment"> * "/foo" into buf.</span>
<span class="comment"> */</span>
<span class="function">jboolean <span class="title">GetApplicationHome</span><span class="params">(<span class="keyword">char</span> *buf, jint bufsize)</span></span>
<span class="function"></span>{
    <span class="comment">//GetExecName()直接返回execname变量，在SetExecname(*pargv)函数中初始化</span>
    <span class="keyword">const</span> <span class="keyword">char</span> *execname = GetExecName();
    <span class="keyword">if</span> (execname != ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        <span class="comment">//将格式化的数据写入字符串,超出则截断</span>
        <span class="built_in">snprintf</span>(buf, bufsize, <span class="string">"%s"</span>, execname);
        buf[bufsize<span class="number">-1</span>] = <span class="string">'\0'</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="comment">//strrchr(const char *str, int c) 在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span>
    <span class="keyword">if</span> (<span class="built_in">strrchr</span>(( buf ), ( <span class="string">'/'</span> )) == <span class="number">0</span>) {
        buf[<span class="number">0</span>] = <span class="string">'\0'</span>;
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="comment">//直接截除最后一次出现'/'以及后面的字符,'/foo/bin/java'-&gt;'/foo/bin'</span>
    *(<span class="built_in">strrchr</span>(( buf ), ( <span class="string">'/'</span> ))) = <span class="string">'\0'</span>;    <span class="comment">/* executable file      */</span>
    <span class="comment">//strlen 计算字符串长度</span>
    <span class="comment">//字符串长度&lt;4，其实就是找不到jdk路径</span>
    <span class="keyword">if</span> (<span class="built_in">strlen</span>(( buf )) &lt; <span class="number">4</span> || <span class="built_in">strrchr</span>(( buf ), ( <span class="string">'/'</span> )) == <span class="number">0</span>) {
        buf[<span class="number">0</span>] = <span class="string">'\0'</span>;
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    <span class="comment">//字符串比较，buf + strlen(( buf ) - 4 实际上是地址的操作或者可以理解为数组下标相加</span>
    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( <span class="string">"/bin"</span> ), ( buf + <span class="built_in">strlen</span>(( buf )) - <span class="number">4</span> )) != <span class="number">0</span>)
        <span class="comment">//直接截除最后一次出现'/'以及后面的字符,'/foo/bin'-&gt;'/foo'</span>
        <span class="comment">//这一段不理解，为什么会有这个判断，从注释看，有可能java命令不在bin目录中，而在bin/sparcv9 或者 bin/amd64目录中</span>
        *(<span class="built_in">strrchr</span>(( buf ), ( <span class="string">'/'</span> ))) = <span class="string">'\0'</span>;        <span class="comment">/* sparcv9 or amd64     */</span>
    <span class="keyword">if</span> (<span class="built_in">strlen</span>(( buf )) &lt; <span class="number">4</span> || <span class="built_in">strcmp</span>(( <span class="string">"/bin"</span> ), ( buf + <span class="built_in">strlen</span>(( buf )) - <span class="number">4</span> )) != <span class="number">0</span>) {
        <span class="comment">//不可能在找到bin目录了</span>
        buf[<span class="number">0</span>] = <span class="string">'\0'</span>;
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    <span class="comment">//直接截除最后一次出现'/'以及后面的字符,'/foo/bin'-&gt;'/foo'</span>
    *(<span class="built_in">strrchr</span>(( buf ), ( <span class="string">'/'</span> ))) = <span class="string">'\0'</span>;    <span class="comment">/* bin                  */</span>

    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre>
<p><code>jvm.cfg</code>文件的定义。默认选择的是<code>server</code>类型。以及<code>knownVMs</code>变量数据结构</p>
<pre><code class="c">-server KNOWN
-client IGNORE

<span class="comment">//knownVMs变量数据结构</span>
<span class="class"><span class="keyword">struct</span> <span class="title">vmdesc</span> {</span>
    <span class="keyword">char</span> *name;
    <span class="keyword">int</span> flag;
    <span class="keyword">char</span> *alias;
    <span class="keyword">char</span> *server_class;
};
<span class="keyword">enum</span> vmdesc_flag {
    VM_UNKNOWN = <span class="number">-1</span>,
    VM_KNOWN,
    VM_ALIASED_TO,
    VM_WARN,
    VM_ERROR,
    VM_IF_SERVER_CLASS,
    VM_IGNORE
};
</code></pre>
<h2 id="动态库加载"><a href="#动态库加载" class="headerlink" title="动态库加载"></a>动态库加载</h2><p>使用<code>dlopen</code>函数打开动态库，并将其中的<code>JNI_CreateJavaVM</code>、<code>JNI_GetDefaultJavaVMInitArgs</code>、<code>JNI_GetCreatedJavaVMs</code>函数链接至<code>ifn</code>变量中。</p>
<pre><code class="c++"><span class="function">jboolean <span class="title">LoadJavaVM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *jvmpath, InvocationFunctions *ifn)</span></span>
<span class="function"></span>{
    <span class="keyword">void</span> *libjvm;

    JLI_TraceLauncher(<span class="string">"JVM path is %s\n"</span>, jvmpath);

    <span class="comment">//打开动态库，立刻模式和全局模式</span>
    libjvm = dlopen(jvmpath,  RTLD_NOW + RTLD_GLOBAL);
    <span class="keyword">if</span> (libjvm == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        JLI_ReportErrorMessage(<span class="string">"Error: dl failure on line %d"</span>, <span class="number">864</span>);
        JLI_ReportErrorMessage(<span class="string">"Error: failed %s, because %s"</span>, jvmpath, dlerror());
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="comment">//函数链接</span>
    ifn-&gt;CreateJavaVM = (CreateJavaVM_t)
        dlsym(libjvm, <span class="string">"JNI_CreateJavaVM"</span>);
    <span class="keyword">if</span> (ifn-&gt;CreateJavaVM == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        JLI_ReportErrorMessage(<span class="string">"Error: failed %s, because %s"</span>, jvmpath, dlerror());
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)
        dlsym(libjvm, <span class="string">"JNI_GetDefaultJavaVMInitArgs"</span>);
    <span class="keyword">if</span> (ifn-&gt;GetDefaultJavaVMInitArgs == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        JLI_ReportErrorMessage(<span class="string">"Error: failed %s, because %s"</span>, jvmpath, dlerror());
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t)
        dlsym(libjvm, <span class="string">"JNI_GetCreatedJavaVMs"</span>);
    <span class="keyword">if</span> (ifn-&gt;GetCreatedJavaVMs == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        JLI_ReportErrorMessage(<span class="string">"Error: failed %s, because %s"</span>, jvmpath, dlerror());
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre>
<h2 id="options解析"><a href="#options解析" class="headerlink" title="options解析"></a>options解析</h2><p>通过<code>AddOption</code>函数将所有<code>options</code>记录在<code>JavaVMOption</code>变量中。</p>
<pre><code class="c++"><span class="function"><span class="keyword">void</span> <span class="title">AddOption</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">void</span> *info)</span></span>
<span class="function"></span>{
    <span class="comment">/*</span>
<span class="comment">     * Expand options array if needed to accommodate at least one more</span>
<span class="comment">     * VM option.</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (numOptions &gt;= maxOptions) {
        <span class="keyword">if</span> (options == <span class="number">0</span>) {
            maxOptions = <span class="number">4</span>;
            options = JLI_MemAlloc(maxOptions * <span class="keyword">sizeof</span>(JavaVMOption));
        } <span class="keyword">else</span> {
            JavaVMOption *tmp;
            maxOptions *= <span class="number">2</span>;
            tmp = JLI_MemAlloc(maxOptions * <span class="keyword">sizeof</span>(JavaVMOption));
            <span class="built_in">memcpy</span>(tmp, options, numOptions * <span class="keyword">sizeof</span>(JavaVMOption));
            JLI_MemFree(options);
            options = tmp;
        }
    }
    <span class="comment">//将参数，插入到options变量中</span>
    options[numOptions].optionString = str;
    options[numOptions++].extraInfo = info;

    <span class="comment">//判断是否是-Xss参数，设置栈大小</span>
    <span class="keyword">if</span> (JLI_StrCCmp(str, <span class="string">"-Xss"</span>) == <span class="number">0</span>) {
        jlong tmp;
        <span class="keyword">if</span> (parse_size(str + <span class="number">4</span>, &amp;tmp)) {
            threadStackSize = tmp;
        }
    }

    <span class="comment">//判断是否是-Xmx参数，设置最大堆内存</span>
    <span class="keyword">if</span> (JLI_StrCCmp(str, <span class="string">"-Xmx"</span>) == <span class="number">0</span>) {
        jlong tmp;
        <span class="keyword">if</span> (parse_size(str + <span class="number">4</span>, &amp;tmp)) {
            maxHeapSize = tmp;
        }
    }

    <span class="comment">//判断是否是-Xmx参数，设置初始堆内存</span>
    <span class="keyword">if</span> (JLI_StrCCmp(str, <span class="string">"-Xms"</span>) == <span class="number">0</span>) {
        jlong tmp;
        <span class="keyword">if</span> (parse_size(str + <span class="number">4</span>, &amp;tmp)) {
           initialHeapSize = tmp;
        }
    }
}
<span class="comment">//options变量结构</span>
<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">JavaVMOption</span> {</span>
    <span class="keyword">char</span> *optionString;
    <span class="keyword">void</span> *extraInfo;
} JavaVMOption;


<span class="comment">//解析options</span>
<span class="function"><span class="keyword">static</span> jboolean <span class="title">ParseArguments</span><span class="params">(<span class="keyword">int</span> *pargc, <span class="keyword">char</span> ***pargv,</span></span>
<span class="function"><span class="params">               <span class="keyword">int</span> *pmode, <span class="keyword">char</span> **pwhat,</span></span>
<span class="function"><span class="params">               <span class="keyword">int</span> *pret, <span class="keyword">const</span> <span class="keyword">char</span> *jrepath)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> argc = *pargc;
    <span class="keyword">char</span> **argv = *pargv;
    <span class="keyword">int</span> mode = LM_UNKNOWN;
    <span class="keyword">char</span> *arg;

    *pret = <span class="number">0</span>;

    <span class="keyword">while</span> ((arg = *argv) != <span class="number">0</span> &amp;&amp; *arg == <span class="string">'-'</span>) {
        argv++; --argc;
        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-classpath"</span> )) == <span class="number">0</span> || <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-cp"</span> )) == <span class="number">0</span>) {
            <span class="keyword">do</span> {
                <span class="keyword">if</span> ( argc &lt; <span class="number">1</span>) {
                    JLI_ReportErrorMessage( <span class="string">"Error: %s requires class path specification"</span> , arg );
                    printUsage = <span class="number">1</span> ;
                    *pret = <span class="number">1</span>;
                    <span class="keyword">return</span> <span class="number">1</span> ;
                }
            }
            <span class="keyword">while</span> ( <span class="number">0</span> );
            SetClassPath(*argv);
            mode = LM_CLASS;
            argv++; --argc;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-jar"</span> )) == <span class="number">0</span>) {
            <span class="keyword">do</span> {
                <span class="keyword">if</span> ( argc &lt; <span class="number">1</span>) {
                    JLI_ReportErrorMessage( <span class="string">"Error: %s requires jar file specification"</span> , arg );
                    printUsage = <span class="number">1</span> ;
                    *pret = <span class="number">1</span>;
                    <span class="keyword">return</span> <span class="number">1</span> ;
                }
            }
            <span class="keyword">while</span> ( <span class="number">0</span> );
            mode = LM_JAR;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-help"</span> )) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-h"</span> )) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-?"</span> )) == <span class="number">0</span>) {
            printUsage = <span class="number">1</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-version"</span> )) == <span class="number">0</span>) {
            printVersion = <span class="number">1</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-showversion"</span> )) == <span class="number">0</span>) {
            showVersion = <span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-X"</span> )) == <span class="number">0</span>) {
            printXUsage = <span class="number">1</span>;
            <span class="keyword">return</span> <span class="number">1</span>;
<span class="comment">/*</span>
<span class="comment"> * The following case checks for -XshowSettings OR -XshowSetting:SUBOPT.</span>
<span class="comment"> * In the latter case, any SUBOPT value not recognized will default to "all"</span>
<span class="comment"> */</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-XshowSettings"</span> )) == <span class="number">0</span> ||
                JLI_StrCCmp(arg, <span class="string">"-XshowSettings:"</span>) == <span class="number">0</span>) {
            showSettings = arg;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-Xdiag"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Dsun.java.launcher.diag=true"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
<span class="comment">/*</span>
<span class="comment"> * The following case provide backward compatibility with old-style</span>
<span class="comment"> * command line options.</span>
<span class="comment"> */</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-fullversion"</span> )) == <span class="number">0</span>) {
            JLI_ReportMessage(<span class="string">"%s full version \"%s\""</span>, _launcher_name, GetFullVersion());
            <span class="keyword">return</span> <span class="number">0</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-verbosegc"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-verbose:gc"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-t"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xt"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-tm"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xtm"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-debug"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xdebug"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-noclassgc"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xnoclassgc"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-Xfuture"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xverify:all"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-verify"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xverify:all"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-verifyremote"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xverify:remote"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-noverify"</span> )) == <span class="number">0</span>) {
            AddOption(<span class="string">"-Xverify:none"</span>, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (JLI_StrCCmp(arg, <span class="string">"-prof"</span>) == <span class="number">0</span>) {
            <span class="keyword">char</span> *p = arg + <span class="number">5</span>;
            <span class="keyword">char</span> *tmp = JLI_MemAlloc(<span class="built_in">strlen</span>(( arg )) + <span class="number">50</span>);
            <span class="keyword">if</span> (*p) {
                <span class="built_in">sprintf</span>(tmp, <span class="string">"-Xrunhprof:cpu=old,file=%s"</span>, p + <span class="number">1</span>);
            } <span class="keyword">else</span> {
                <span class="built_in">sprintf</span>(tmp, <span class="string">"-Xrunhprof:cpu=old,file=java.prof"</span>);
            }
            AddOption(tmp, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (JLI_StrCCmp(arg, <span class="string">"-ss"</span>) == <span class="number">0</span> ||
                   JLI_StrCCmp(arg, <span class="string">"-oss"</span>) == <span class="number">0</span> ||
                   JLI_StrCCmp(arg, <span class="string">"-ms"</span>) == <span class="number">0</span> ||
                   JLI_StrCCmp(arg, <span class="string">"-mx"</span>) == <span class="number">0</span>) {
            <span class="keyword">char</span> *tmp = JLI_MemAlloc(<span class="built_in">strlen</span>(( arg )) + <span class="number">6</span>);
            <span class="built_in">sprintf</span>(tmp, <span class="string">"-X%s"</span>, arg + <span class="number">1</span>); <span class="comment">/* skip '-' */</span>
            AddOption(tmp, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-checksource"</span> )) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-cs"</span> )) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-noasyncgc"</span> )) == <span class="number">0</span>) {
            <span class="comment">/* No longer supported */</span>
            JLI_ReportErrorMessage(<span class="string">"Warning: %s option is no longer supported."</span>, arg);
        } <span class="keyword">else</span> <span class="keyword">if</span> (JLI_StrCCmp(arg, <span class="string">"-version:"</span>) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-no-jre-restrict-search"</span> )) == <span class="number">0</span> ||
                   <span class="built_in">strcmp</span>(( arg ), ( <span class="string">"-jre-restrict-search"</span> )) == <span class="number">0</span> ||
                   JLI_StrCCmp(arg, <span class="string">"-splash:"</span>) == <span class="number">0</span>) {
            ; <span class="comment">/* Ignore machine independent options already handled */</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (ProcessPlatformOption(arg)) {
            ; <span class="comment">/* Processing of platform dependent options */</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (RemovableOption(arg)) {
            ; <span class="comment">/* Do not pass option to vm. */</span>
        } <span class="keyword">else</span> {
            AddOption(arg, ((<span class="keyword">void</span> *)<span class="number">0</span>));
        }
    }

    <span class="keyword">if</span> (--argc &gt;= <span class="number">0</span>) {
        *pwhat = *argv++;
    }

    <span class="keyword">if</span> (*pwhat == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        *pret = <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (mode == LM_UNKNOWN) {
        <span class="comment">/* default to LM_CLASS if -jar and -cp option are</span>
<span class="comment">         * not specified */</span>
        mode = LM_CLASS;
    }

    <span class="keyword">if</span> (argc &gt;= <span class="number">0</span>) {
        *pargc = argc;
        *pargv = argv;
    }

    *pmode = mode;

    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre>
<h2 id="开启线程初始化虚拟机并执行main方法"><a href="#开启线程初始化虚拟机并执行main方法" class="headerlink" title="开启线程初始化虚拟机并执行main方法"></a>开启线程初始化虚拟机并执行main方法</h2><p>开启线程传入线程执行的函数<code>JavaMain</code>，在<code>JavaMain</code>中初始化虚拟机并找到主类和执行<code>main</code>方法。</p>
<pre><code class="c++"><span class="comment">//开启新线程初始化JVM</span>
ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
                    <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv,
                    <span class="keyword">int</span> mode, <span class="keyword">char</span> *what, <span class="keyword">int</span> ret)
{

    <span class="comment">/*</span>
<span class="comment">     * If user doesn't specify stack size, check if VM has a preference.</span>
<span class="comment">     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span>
<span class="comment">     * return its default stack size through the init args structure.</span>
<span class="comment">     */</span>
     <span class="comment">//如果用户没有用"-Xss"参数指定栈深，则使用默认的，通过GetDefaultJavaVMInitArgs函数获取</span>
    <span class="keyword">if</span> (threadStackSize == <span class="number">0</span>) {
      <span class="class"><span class="keyword">struct</span> <span class="title">JDK1_1InitArgs</span> <span class="title">args1_1</span>;</span>
      <span class="built_in">memset</span>((<span class="keyword">void</span>*)&amp;args1_1, <span class="number">0</span>, <span class="keyword">sizeof</span>(args1_1));
      args1_1.version = <span class="number">0x00010001</span>;
      ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  <span class="comment">/* ignore return value */</span>
      <span class="keyword">if</span> (args1_1.javaStackSize &gt; <span class="number">0</span>) {
         threadStackSize = args1_1.javaStackSize;
      }
    }

    { <span class="comment">/* Create a new thread to create JVM and invoke main method */</span>
      JavaMainArgs args;
      <span class="keyword">int</span> rslt;

      args.argc = argc;
      args.argv = argv;
      args.mode = mode;
      args.what = what;
      args.ifn = *ifn;

      <span class="comment">//创建线程，第一个参数是线程执行函数，第二个是线程属性，第三个是函数参数</span>
      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (<span class="keyword">void</span>*)&amp;args);
      <span class="comment">/* If the caller has deemed there is an error we</span>
<span class="comment">       * simply return that, otherwise we return the value of</span>
<span class="comment">       * the callee</span>
<span class="comment">       */</span>
      <span class="keyword">return</span> (ret != <span class="number">0</span>) ? ret : rslt;
    }
}

int ContinueInNewThread0(int ( *continuation)(void *), jlong stack_size, void * args) {
    <span class="keyword">int</span> rslt;
    <span class="keyword">pthread_t</span> tid;
    <span class="keyword">pthread_attr_t</span> attr;
    pthread_attr_init(&amp;attr);
    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

    <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) {
      pthread_attr_setstacksize(&amp;attr, stack_size);
    }
    <span class="comment">//第一个参数为指向线程标识符的指针。第二个参数用来设置线程属性。</span>
    <span class="comment">//第三个参数是线程运行函数的起始地址。最后一个参数是运行函数的参数。</span>
    <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span>*))continuation, (<span class="keyword">void</span>*)args) == <span class="number">0</span>) {
      <span class="keyword">void</span> * tmp;
      <span class="comment">//代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。</span>
      <span class="comment">//加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。</span>
      pthread_join(tid, &amp;tmp);
      rslt = (<span class="keyword">int</span>)tmp;
    } <span class="keyword">else</span> {
     <span class="comment">/*</span>
<span class="comment">      * Continue execution in current thread if for some reason (e.g. out of</span>
<span class="comment">      * memory/LWP)  a new thread can't be created. This will likely fail</span>
<span class="comment">      * later in continuation as JNI_CreateJavaVM needs to create quite a</span>
<span class="comment">      * few new threads, anyway, just give it a try..</span>
<span class="comment">      */</span>
      <span class="comment">//直接执行函数</span>
      rslt = continuation(args);
    }

    pthread_attr_destroy(&amp;attr);
    <span class="keyword">return</span> rslt;
}


<span class="function"><span class="keyword">int</span> <span class="title">JavaMain</span><span class="params">(<span class="keyword">void</span> * _args)</span></span>
<span class="function"></span>{
    JavaMainArgs *args = (JavaMainArgs *)_args;
    <span class="keyword">int</span> argc = args-&gt;argc;
    <span class="keyword">char</span> **argv = args-&gt;argv;
    <span class="keyword">int</span> mode = args-&gt;mode;
    <span class="keyword">char</span> *what = args-&gt;what;
    InvocationFunctions ifn = args-&gt;ifn;

    <span class="comment">//这两个参数在创建虚拟机时被初始化</span>
    JavaVM *vm = <span class="number">0</span>;
    JNIEnv *env = <span class="number">0</span>;
    jclass mainClass = ((<span class="keyword">void</span> *)<span class="number">0</span>);
    jclass appClass = ((<span class="keyword">void</span> *)<span class="number">0</span>); <span class="comment">// actual application class being launched</span>
    jmethodID mainID;
    jobjectArray mainArgs;
    <span class="keyword">int</span> ret = <span class="number">0</span>;
    jlong start, end;

    <span class="comment">//Linux 并未实现</span>
    RegisterThread();

    <span class="comment">/* Initialize the virtual machine */</span>
    start = (<span class="number">0</span>);
    <span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) {
        JLI_ReportErrorMessage(<span class="string">"Error: Could not create the Java Virtual Machine.\n"</span> 
        <span class="string">"Error: A fatal exception has occurred. Program will exit."</span>);
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }

    <span class="keyword">if</span> (showSettings != ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        ShowSettings(env, showSettings);
        ......
    }

    <span class="keyword">if</span> (printVersion || showVersion) {
        PrintJavaVersion(env, showVersion);
        ......
    }

    <span class="comment">/* If the user specified neither a class name nor a JAR file */</span>
    <span class="keyword">if</span> (printXUsage || printUsage || what == <span class="number">0</span> || mode == LM_UNKNOWN) {
        PrintUsage(env, printXUsage);
        ......
    }

    <span class="comment">//释放Knownvms变量</span>
    FreeKnownVMs();  <span class="comment">/* after last possible PrintUsage() */</span>

    <span class="comment">//打印调试的信息</span>
    ......

    ret = <span class="number">1</span>;

    <span class="comment">/*</span>
<span class="comment">     * Get the application's main class.</span>
<span class="comment">     *</span>
<span class="comment">     * See bugid 5030265.  The Main-Class name has already been parsed</span>
<span class="comment">     * from the manifest, but not parsed properly for UTF-8 support.</span>
<span class="comment">     * Hence the code here ignores the value previously extracted and</span>
<span class="comment">     * uses the pre-existing code to reextract the value.  This is</span>
<span class="comment">     * possibly an end of release cycle expedient.  However, it has</span>
<span class="comment">     * also been discovered that passing some character sets through</span>
<span class="comment">     * the environment has "strange" behavior on some variants of</span>
<span class="comment">     * Windows.  Hence, maybe the manifest parsing code local to the</span>
<span class="comment">     * launcher should never be enhanced.</span>
<span class="comment">     *</span>
<span class="comment">     * Hence, future work should either:</span>
<span class="comment">     *     1)   Correct the local parsing code and verify that the</span>
<span class="comment">     *          Main-Class attribute gets properly passed through</span>
<span class="comment">     *          all environments,</span>
<span class="comment">     *     2)   Remove the vestages of maintaining main_class through</span>
<span class="comment">     *          the environment (and remove these comments).</span>
<span class="comment">     *</span>
<span class="comment">     * This method also correctly handles launching existing JavaFX</span>
<span class="comment">     * applications that may or may not have a Main-Class manifest entry.</span>
<span class="comment">     */</span>
    <span class="comment">//获取主类</span>
    mainClass = LoadMainClass(env, mode, what);
    CHECK_EXCEPTION_NULL_LEAVE(mainClass);
    <span class="comment">/*</span>
<span class="comment">     * In some cases when launching an application that needs a helper, e.g., a</span>
<span class="comment">     * JavaFX application with no main method, the mainClass will not be the</span>
<span class="comment">     * applications own main class but rather a helper class. To keep things</span>
<span class="comment">     * consistent in the UI we need to track and report the application main class.</span>
<span class="comment">     */</span>
    <span class="comment">//在checkAndLoadMain方法中已经赋值为mainClass</span>
    appClass = GetApplicationClass(env);
    NULL_CHECK_RETURN_VALUE(appClass, <span class="number">-1</span>);
    <span class="comment">/*</span>
<span class="comment">     * PostJVMInit uses the class name as the application name for GUI purposes,</span>
<span class="comment">     * for example, on OSX this sets the application name in the menu bar for</span>
<span class="comment">     * both SWT and JavaFX. So we'll pass the actual application class here</span>
<span class="comment">     * instead of mainClass as that may be a launcher or helper class instead</span>
<span class="comment">     * of the application class.</span>
<span class="comment">     */</span>
    <span class="comment">//Linux未实现</span>
    PostJVMInit(env, appClass, vm);
    <span class="comment">/*</span>
<span class="comment">     * The LoadMainClass not only loads the main class, it will also ensure</span>
<span class="comment">     * that the main method's signature is correct, therefore further checking</span>
<span class="comment">     * is not required. The main method is invoked here so that extraneous java</span>
<span class="comment">     * stacks are not in the application stack trace.</span>
<span class="comment">     */</span>
     <span class="comment">//获取main方法的引用</span>
    mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">"main"</span>,
                                       <span class="string">"([Ljava/lang/String;)V"</span>);
    CHECK_EXCEPTION_NULL_LEAVE(mainID);

    <span class="comment">/* Build platform specific argument array */</span>
    <span class="comment">//创建java类型的参数</span>
    mainArgs = CreateApplicationArgs(env, argv, argc);
    CHECK_EXCEPTION_NULL_LEAVE(mainArgs);

    <span class="comment">/* Invoke main method. */</span>
    <span class="comment">//调用main方法</span>
    (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);

    <span class="comment">/*</span>
<span class="comment">     * The launcher's exit code (in the absence of calls to</span>
<span class="comment">     * System.exit) will be non-zero if main threw an exception.</span>
<span class="comment">     */</span>
    ret = (*env)-&gt;ExceptionOccurred(env) == ((<span class="keyword">void</span> *)<span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;
    LEAVE();
}
</code></pre>
<h3 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a>初始化虚拟机</h3><p>虚拟机初始化的具体实现并不在<code>java.c</code>文件中，而是在动态链接库中，其实现比较复杂，大体上应该是创建虚拟机环境，包括内存模型、线程模型、以及垃圾回收等。返回虚拟机环境的一些接口，这些接口定义在<code>jni.h</code>文件中。这里不对实现做深入研究，简单看下几个接口的作用。<br>请参考:[<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html</a>]</p>
<ul>
<li><code>jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz,const char *name, const char *sig);</code>获取类中静态方法的引用。参数分别是：虚拟机环境、类、方法名、方法声明。</li>
<li><code>CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz,jmethodID methodID, ...);</code>调用静态方法。<code>...</code>是方法参数。</li>
</ul>
<pre><code class="c++">
<span class="comment">//初始化JVM  ifn是JAVA_DLL库中的几个函数</span>
<span class="keyword">static</span> jboolean
InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
{
    JavaVMInitArgs args;
    jint r;

    <span class="comment">//作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</span>
    <span class="built_in">memset</span>(&amp;args, <span class="number">0</span>, <span class="keyword">sizeof</span>(args));
    <span class="comment">//下面这些参数在环境准备时已经准备好了</span>
    args.version  = <span class="number">0x00010002</span>;
    args.nOptions = numOptions;
    args.options  = options;
    args.ignoreUnrecognized = <span class="number">0</span>;

    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {
        <span class="keyword">int</span> i = <span class="number">0</span>;
        <span class="built_in">printf</span>(<span class="string">"JavaVM args:\n    "</span>);
        <span class="built_in">printf</span>(<span class="string">"version 0x%08lx, "</span>, (<span class="keyword">long</span>)args.version);
        <span class="built_in">printf</span>(<span class="string">"ignoreUnrecognized is %s, "</span>,
               args.ignoreUnrecognized ? <span class="string">"JNI_TRUE"</span> : <span class="string">"JNI_FALSE"</span>);
        <span class="built_in">printf</span>(<span class="string">"nOptions is %ld\n"</span>, (<span class="keyword">long</span>)args.nOptions);
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numOptions; i++)
            <span class="built_in">printf</span>(<span class="string">"    option[%2d] = '%s'\n"</span>,
                   i, args.options[i].optionString);
    }
    <span class="comment">//创建虚拟机实例并返回，之前只是加载动态库，到这里才正式创建虚拟机</span>
    r = ifn-&gt;CreateJavaVM(pvm, (<span class="keyword">void</span> **)penv, &amp;args);
    JLI_MemFree(options);
    <span class="keyword">return</span> r == <span class="number">0</span>;
}
</code></pre>
<h3 id="加载主类"><a href="#加载主类" class="headerlink" title="加载主类"></a>加载主类</h3><p><code>JVM</code>加载<code>HelloJNI</code>类时并不是直接加载，而是先加载<code>sun.launcher.LauncherHelper</code>,调用该类中的<code>checkAndLoadMain</code>方法去加载<code>HelloJNI</code>类。然后在调用<code>HelloJNI</code>的<code>main</code>方法。这样做的目的是把类加载的方式交给用户自己定义。</p>
<pre><code class="c++"><span class="comment">//加载主类</span>
<span class="keyword">static</span> jclass
LoadMainClass(JNIEnv *env, <span class="keyword">int</span> mode, <span class="keyword">char</span> *name)
{
    jmethodID mid;
    jstring str;
    jobject result;
    jlong start, end;
    <span class="comment">//找到 sun/launcher/LauncherHelper 类</span>
    jclass cls = GetLauncherHelperClass(env);
    <span class="comment">//检查是否为null</span>
    NULL_CHECK0(cls);
    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {
        start = (<span class="number">0</span>);
    }
    <span class="comment">//用虚拟机提供的函数获取"sun/launcher/LauncherHelper"类中"checkAndLoadMain"静态方法</span>
    NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
                <span class="string">"checkAndLoadMain"</span>,
                <span class="string">"(ZILjava/lang/String;)Ljava/lang/Class;"</span>));

    <span class="comment">//获取java语言中的String，java中String是个对象，而不是字符数组</span>
    str = NewPlatformString(env, name);
    <span class="comment">//调用checkAndLoadMain方法，加载主类</span>
    result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, <span class="number">1</span>, mode, str);

    <span class="keyword">if</span> (JLI_IsTraceLauncher()) {
        end   = (<span class="number">0</span>);
        <span class="built_in">printf</span>(<span class="string">"%ld micro seconds to load main class\n"</span>,
               (<span class="keyword">long</span>)(jint)(<span class="number">1</span>));
        <span class="built_in">printf</span>(<span class="string">"----%s----\n"</span>, <span class="string">"_JAVA_LAUNCHER_DEBUG"</span>);
    }

    <span class="keyword">return</span> (jclass)result;
}

<span class="function">jclass <span class="title">GetLauncherHelperClass</span><span class="params">(JNIEnv *env)</span></span>
<span class="function"></span>{
    <span class="keyword">if</span> (helperClass == ((<span class="keyword">void</span> *)<span class="number">0</span>)) {
        <span class="keyword">do</span> {
            <span class="keyword">if</span> (( helperClass = FindBootStrapClass ( env , <span class="string">"sun/launcher/LauncherHelper"</span> ) ) == ((<span class="keyword">void</span> *)<span class="number">0</span>) ) {
                JLI_ReportErrorMessage( <span class="string">"Error: A JNI error has occurred, please check your installation and try again"</span> );
                <span class="keyword">return</span> <span class="number">0</span> ;
            }
        }
        <span class="keyword">while</span> ( <span class="number">0</span> );
    }
    <span class="keyword">return</span> helperClass;
}


<span class="function">jclass <span class="title">FindBootStrapClass</span><span class="params">(JNIEnv *env, <span class="keyword">const</span> <span class="keyword">char</span>* classname)</span></span>
<span class="function"></span>{
   <span class="keyword">if</span> (findBootClass == <span class="literal">NULL</span>) {
       <span class="comment">//根据 动态链接库 操作句柄(handle)与符号(symbol)，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。</span>
       <span class="comment">//在handle为RTLD_DEFAULT的情况中，linker将遍历系统中已经加载的所有动态链接库，并在每一个动态连接库里查找那个符号。</span>
       <span class="comment">//获取函数JVM_FindClassFromBootLoader的指针</span>
       findBootClass = (FindClassFromBootLoader_t *)dlsym(RTLD_DEFAULT,
          <span class="string">"JVM_FindClassFromBootLoader"</span>);
       <span class="keyword">if</span> (findBootClass == <span class="literal">NULL</span>) {
           JLI_ReportErrorMessage(DLL_ERROR4,
               <span class="string">"JVM_FindClassFromBootLoader"</span>);
           <span class="keyword">return</span> <span class="literal">NULL</span>;
       }
   }
   <span class="keyword">return</span> findBootClass(env, classname);
}

<span class="comment">/*</span>
<span class="comment"> * Returns a new Java string object for the specified platform string.</span>
<span class="comment"> */</span>
<span class="function"><span class="keyword">static</span> jstring <span class="title">NewPlatformString</span><span class="params">(JNIEnv *env, <span class="keyword">char</span> *s)</span></span>
<span class="function"></span>{
    <span class="keyword">int</span> len = (<span class="keyword">int</span>)JLI_StrLen(s);
    jbyteArray ary;
    jclass cls = GetLauncherHelperClass(env);
    NULL_CHECK0(cls);
    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)
        <span class="keyword">return</span> <span class="number">0</span>;

    ary = (*env)-&gt;NewByteArray(env, len);
    <span class="keyword">if</span> (ary != <span class="number">0</span>) {
        jstring str = <span class="number">0</span>;
        (*env)-&gt;SetByteArrayRegion(env, ary, <span class="number">0</span>, len, (jbyte *)s);
        <span class="keyword">if</span> (!(*env)-&gt;ExceptionOccurred(env)) {
            <span class="keyword">if</span> (makePlatformStringMID == <span class="literal">NULL</span>) {
                NULL_CHECK0(makePlatformStringMID = (*env)-&gt;GetStaticMethodID(env,
                        cls, <span class="string">"makePlatformString"</span>, <span class="string">"(Z[B)Ljava/lang/String;"</span>));
            }
            str = (*env)-&gt;CallStaticObjectMethod(env, cls,
                    makePlatformStringMID, USE_STDERR, ary);
            (*env)-&gt;DeleteLocalRef(env, ary);
            <span class="keyword">return</span> str;
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
<p>而checkAndLoadMain又做了哪些事情呢。</p>
<ul>
<li>如果是<code>jar</code>模式，则从<code>manifest</code>文件中获取类名。</li>
<li>使用<code>System ClassLoader</code>加载类。</li>
<li>确保<code>main</code>方法的有效性和可访问。</li>
<li><code>FX Application</code>相关。</li>
</ul>
<pre><code class="java"><span class="comment">/**</span>
<span class="comment"> * This method does the following:</span>
<span class="comment"> * 1. gets the classname from a Jar's manifest, if necessary</span>
<span class="comment"> * 2. loads the class using the System ClassLoader</span>
<span class="comment"> * 3. ensures the availability and accessibility of the main method,</span>
<span class="comment"> *    using signatureDiagnostic method.</span>
<span class="comment"> *    a. does the class exist</span>
<span class="comment"> *    b. is there a main</span>
<span class="comment"> *    c. is the main public</span>
<span class="comment"> *    d. is the main static</span>
<span class="comment"> *    e. does the main take a String array for args</span>
<span class="comment"> * 4. if no main method and if the class extends FX Application, then call</span>
<span class="comment"> *    on FXHelper to determine the main class to launch</span>
<span class="comment"> * 5. and off we go......</span>
<span class="comment"> *</span>
<span class="comment"> * <span class="doctag">@param</span> printToStderr if set, all output will be routed to stderr</span>
<span class="comment"> * <span class="doctag">@param</span> mode LaunchMode as determined by the arguments passed on the</span>
<span class="comment"> * command line</span>
<span class="comment"> * <span class="doctag">@param</span> what either the jar file to launch or the main class when using</span>
<span class="comment"> * LM_CLASS mode</span>
<span class="comment"> * <span class="doctag">@return</span> the application's main class</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; checkAndLoadMain(<span class="keyword">boolean</span> printToStderr,
                                        <span class="keyword">int</span> mode,
                                        String what) {
    initOutput(printToStderr);
    <span class="comment">// get the class name</span>
    String cn = <span class="keyword">null</span>;
    <span class="keyword">switch</span> (mode) {
        <span class="keyword">case</span> LM_CLASS:
            cn = what;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> LM_JAR:
            cn = getMainClassFromJar(what);
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="comment">// should never happen</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">""</span> + mode + <span class="string">": Unknown launch mode"</span>);
    }
    cn = cn.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);
    Class&lt;?&gt; mainClass = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        mainClass = scloader.loadClass(cn);
    } <span class="keyword">catch</span> (NoClassDefFoundError | ClassNotFoundException cnfe) {
        <span class="keyword">if</span> (System.getProperty(<span class="string">"os.name"</span>, <span class="string">""</span>).contains(<span class="string">"OS X"</span>)
            &amp;&amp; Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {
            <span class="keyword">try</span> {
                <span class="comment">// On Mac OS X since all names with diacretic symbols are given as decomposed it</span>
                <span class="comment">// is possible that main class name comes incorrectly from the command line</span>
                <span class="comment">// and we have to re-compose it</span>
                mainClass = scloader.loadClass(Normalizer.normalize(cn, Normalizer.Form.NFC));
            } <span class="keyword">catch</span> (NoClassDefFoundError | ClassNotFoundException cnfe1) {
                abort(cnfe, <span class="string">"java.launcher.cls.error1"</span>, cn);
            }
        } <span class="keyword">else</span> {
            abort(cnfe, <span class="string">"java.launcher.cls.error1"</span>, cn);
        }
    }
    <span class="comment">// set to mainClass</span>
    appClass = mainClass;

    <span class="comment">/*</span>
<span class="comment">     * Check if FXHelper can launch it using the FX launcher. In an FX app,</span>
<span class="comment">     * the main class may or may not have a main method, so do this before</span>
<span class="comment">     * validating the main class.</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (mainClass.equals(FXHelper.class) ||
            FXHelper.doesExtendFXApplication(mainClass)) {
        <span class="comment">// Will abort() if there are problems with the FX runtime</span>
        FXHelper.setFXLaunchParameters(what, mode);
        <span class="keyword">return</span> FXHelper.class;
    }

    validateMainClass(mainClass);
    <span class="keyword">return</span> mainClass;
}
</code></pre>
<blockquote>
<p>参考：<a href="http://www.jianshu.com/p/b91258bc08ac" target="_blank" rel="noopener">简书占小狼</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> OpenJDK </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JNDI是什么]]></title>
      <url>/2017/12/08/JNDI%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<blockquote>
<p>面向对象，就意味着对象之间的依赖不可避免。而好的应用程序必然是可维护性高，可扩展性强。依赖或者说耦合是这两者的天敌，耦合度越高程序就越不灵活，所以各种框架各种规范蜂拥崛起，其根本目的就是为了解耦。</p>
</blockquote>
<h1 id="为什么会出现JNDI"><a href="#为什么会出现JNDI" class="headerlink" title="为什么会出现JNDI"></a>为什么会出现JNDI</h1><p>在讲<code>JNDI</code>前,先来回忆一下绝大多数<code>Java</code>程序员是如何访问数据库的。<br><a id="more"></a></p>
<h2 id="在程序中进行JDBC编码"><a href="#在程序中进行JDBC编码" class="headerlink" title="在程序中进行JDBC编码"></a>在程序中进行JDBC编码</h2><p>记得刚入门时，第一次进行<code>JDBC</code>编程用的是<code>MySQL</code>数据库，写了一大坨代码实现了对数据库的访问，当时的心情非常兴奋。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   Connection conn = <span class="keyword">null</span>;
   Statement stmt = <span class="keyword">null</span>;
   <span class="keyword">try</span>{
      <span class="comment">//加载驱动包</span>
      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);

      <span class="comment">//打开连接</span>
      conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/test"</span>,<span class="string">"username"</span>,<span class="string">"username"</span>);

      <span class="comment">//查询</span>
      stmt = conn.createStatement();
      String sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;
      ResultSet rs = stmt.executeQuery(sql);

      <span class="comment">//打印查询数据</span>
      <span class="keyword">while</span>(rs.next()){
         <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);
         <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);
         String first = rs.getString(<span class="string">"first"</span>);
         String last = rs.getString(<span class="string">"last"</span>);
         System.out.print(<span class="string">"ID: "</span> + id);
         System.out.print(<span class="string">", Age: "</span> + age);
         System.out.print(<span class="string">", First: "</span> + first);
         System.out.println(<span class="string">", Last: "</span> + last);
      }
      <span class="comment">//释放资源</span>
      rs.close();
      stmt.close();
      conn.close();
   }<span class="keyword">catch</span>(SQLException se){
      se.printStackTrace();
   }<span class="keyword">catch</span>(Exception e){
      e.printStackTrace();
   }<span class="keyword">finally</span>{
      <span class="comment">//释放资源</span>
      <span class="keyword">try</span>{
         <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)
            stmt.close();
      }<span class="keyword">catch</span>(SQLException se2){
      }
      <span class="keyword">try</span>{
         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)
            conn.close();
      }<span class="keyword">catch</span>(SQLException se){
         se.printStackTrace();
      }
   }
}
</code></pre>
<h2 id="配置文件配置连接池"><a href="#配置文件配置连接池" class="headerlink" title="配置文件配置连接池"></a>配置文件配置连接池</h2><p>后来进入工作了，上面的方式给我们带来很大的麻烦，测试环境和生产环境数据库连接不一样，用户名密码也不一样，这样在发布时很麻烦，要将程序改一遍，还要重新编译才能上线，上线后发现连接错了又要重新编译，烦不胜烦而且耽误时间。上面的一大坨代码看着就头疼。于是<code>Hibernate</code>这种框架，将数据源配置在配置文件中。</p>
<pre><code class="xml"><span class="comment">&lt;!-- 配置数据源 --&gt;</span>
<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://192.168.4.5:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"username-test"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"pwd"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"20"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"3000"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"300000"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1 FROM DUAL"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span>
<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
</code></pre>
<p>上面的方法看上去很不错，我相信大部分<code>JavaWeb</code>程序员都会是用这种方式去访问数据库的。把数据库连接交给<code>Spring</code>容器管理，程序员只需要关心配置就行了，有什么问题改下配置就行了。这样的方式看上去没什么毛病，但不是最好的解决方案。</p>
<h2 id="J2EE中的角色分配"><a href="#J2EE中的角色分配" class="headerlink" title="J2EE中的角色分配"></a>J2EE中的角色分配</h2><h3 id="组件提供者"><a href="#组件提供者" class="headerlink" title="组件提供者"></a>组件提供者</h3><p>这个角色负责创建 <code>J2EE</code> 组件，J2EE 组件可以是 <code>Web</code> 应用程序、企业级 <code>JavaBean（EJB）</code>组件，或者是应用程序客户机（例如基于 <code>Swing</code> 的 <code>GUI</code> 客户机应用程序）。组件提供者包括：<code>HTML</code> 设计师、文档编程人员以及其他开发人员角色。大多数 <code>J2EE</code> 开发人员在组件提供者这一角色上耗费了相当多的时间。</p>
<h3 id="应用程序组装者"><a href="#应用程序组装者" class="headerlink" title="应用程序组装者"></a>应用程序组装者</h3><p>这个角色将多个 <code>J2EE</code> 模块捆绑成一个彼此结合的、可以部署的整体：企业归档<code>（EAR）</code>文件。应用程序组装者要选择组件，分清它们之间的交互方式，配置它们的安全性和事务属性，并把应用程序打包到 <code>EAR</code> 文件中。许多 <code>IDE</code>，例如 <code>WebSphere® Studio</code>、<code>IDEA</code>、<code>JBuilder</code>、<code>WebLogic Workshop</code> 和其他 <code>IDE</code>，都可以帮助应用程序组装者以交互方式配置 <code>EAR</code> 文件。</p>
<h3 id="部署人员"><a href="#部署人员" class="headerlink" title="部署人员"></a>部署人员</h3><p>这个角色负责部署，这意味着将 EAR 安装到 J2EE 容器（应用服务器）中，然后配置资源（例如数据库连接池），把应用程序需要的资源绑定到应用服务器中的特定资源上，并启动应用程序。</p>
<h3 id="系统管理员"><a href="#系统管理员" class="headerlink" title="系统管理员"></a>系统管理员</h3><p>这个角色负责保证容器需要的资源可用于容器。</p>
<p>在许多公司中，上面的分工并不明确，程序员既要关心数据库配置对数据库性能的影响，以及其他的资源连接，又要关心组件的业务逻辑。特别是小公司，程序员往往都是身兼以上4个角色的任务,这就导致资源配置的工作放在了程序中或者是部署文件中。从而造成各个角色之间的强烈耦合，一旦项目变得复杂，开发人员越来越多，项目的分工会变得很难。</p>
<p>项目开发是分角色的，要降低不同角色之间的耦合。比如要使用某个远程对象，远程对象在哪里，这本应该是部署人员来管理的，如果在开发时就将资源部署内容硬编码，那么就增大了之后修改部署的难度。这就是<code>JDNI</code>产生的原因。部署人员负责确保部署环境中存在组件所需的资源，并将组件绑定到平台的可用资源上。开发和测试组件时，为了临时测试代码，开发人员要承担一些部署方面的职责。重要的是要理解：这么做的时候，您就走出了开发人员的领域。最好开发人员能忽略将要访问的特定外部资源，只需要知道其他人会提供使用这些外部资源所需的链接即可。</p>
<h1 id="JNDI是什么"><a href="#JNDI是什么" class="headerlink" title="JNDI是什么"></a>JNDI是什么</h1><p><code>JNDI</code>是 <code>Java</code> 命名与目录接口（<code>Java Naming and Directory Interface</code>），是一组在<code>Java</code>应用中访问命名和目录服务的<code>API</code>，或者说在应用中引用与程序无关的外部资源（可能是数据库资源，也可能是其他资源），降低了应用和其他应用程序组件之间的耦合，使应用更加易于配置、易于部署。在<code>J2EE</code>规范中是重要的规范之一。<br><img src="JNDI.png" alt="JNDI"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li><code>JNDI</code> 提出的目的是为了解藕，是为了开发更加容易维护，容易扩展，容易部署的应用。 </li>
<li><code>JNDI</code> 是一个<code>sun</code>提出的一个规范,具体的实现是各个<code>j2ee</code>容器提供商，<code>sun</code>只是要求，<code>j2ee</code>容器必须有JNDI这样的功能。</li>
<li><code>JNDI</code> 在<code>j2ee</code>系统中的角色是“交换机”，是<code>J2EE</code>组件在运行时间接地查找其他组件、资源或服务的通用机制。</li>
</ul>
<h3 id="命名和目录服务"><a href="#命名和目录服务" class="headerlink" title="命名和目录服务"></a>命名和目录服务</h3><p>关于命名服务,其实我们很多时候都在用它,但是并不知道它是它,比较典型的是域名服务器<code>DNS</code>(<code>Domain Naming Service</code>),大对人对<code>DN</code>S还是比较了解的,它是将域名映射到<code>IP</code>地址的服务.比如百度的域名<code>www.baidu.com</code>所映射的IP地址是<code>http://202.108.22.5/</code>,你在浏览器中输入两个内容是到的同一个页面.用命名服务器的原因是因为我们记忆<code>baidu</code>这几个有意义的字母要比记<code>202.108.22.5</code>更容易记忆,但如果站到计算机的角度上,它更喜欢处理这些数字。<br>从我们生活中找的话还有很多类似的例子,比如说你的身份证号和你的名字可以”理解”成一种命名服务,你的学号和姓名也可以”解释”为一种命名服务。<br>可以看出命名服务的特点:<strong>一个值和另一个值的映射,将我们人类更容易认识的值同计算机更容易认识的值进行一一映射。</strong></p>
<p>至于目录服务,从计算机角度理解为在互联网上有着各种各样的资源和主机,但是这些内容都是散落在互联网中,为了访问这些散落的资源并获得相应的服务,就需要用到目录服务。<br>从我们日常生活中去理解目录服务的概念可以从电话簿说起,电话簿本身就是一个比较典型的目录服务,如果你要找到某个人的电话号码,你需要从电话簿里找到这个人的名称,然后再看其电话号码。</p>
<h1 id="Tomcat中的JNDI资源"><a href="#Tomcat中的JNDI资源" class="headerlink" title="Tomcat中的JNDI资源"></a>Tomcat中的JNDI资源</h1><h2 id="Tomcat配置JNDI数据源"><a href="#Tomcat配置JNDI数据源" class="headerlink" title="Tomcat配置JNDI数据源"></a>Tomcat配置JNDI数据源</h2><p>在<code>Tomcat</code>的<code>/conf/context.xml</code>文件中配置<code>JNDI</code>数据源,<code>Tomcat</code>能够自动检测到<code>context.xml</code>文件内容的修改，并重新加载（未验证）。<code>JNDI</code>规范允许我们通过对象的“名称”来访问这个数据源对象。</p>
<pre><code class="xml"><span class="comment">&lt;!-- JDBC数据源 --&gt;</span>
<span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"mysql-jndi-test"</span></span>
<span class="tag">  <span class="attr">auth</span>=<span class="string">"Container"</span> </span>
<span class="tag">  <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></span>
<span class="tag">  <span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span>
<span class="tag">  <span class="attr">url</span>=<span class="string">"jdbc:mysql://192.168.4.5:3306/grain-trading?useUnicode=true&amp;amp;characterEncoding=utf-8"</span></span>
<span class="tag">  <span class="attr">username</span>=<span class="string">"root"</span></span>
<span class="tag">  <span class="attr">password</span>=<span class="string">"pwd"</span></span>
<span class="tag">  <span class="attr">maxActiv</span> =<span class="string">"20"</span></span>
<span class="tag">  <span class="attr">maxIdle</span>=<span class="string">"1"</span></span>
<span class="tag">  <span class="attr">maxWait</span>=<span class="string">"1"</span></span>
<span class="tag">/&gt;</span>
</code></pre>
<p>定义<code>Resource</code>的名称为<code>mysql-jndi-test</code>，可以定义多个<code>&lt;Resource&gt;</code>节点来连接多个数据库。</p>
<h2 id="在web-xml中配置资源引用"><a href="#在web-xml中配置资源引用" class="headerlink" title="在web.xml中配置资源引用"></a>在web.xml中配置资源引用</h2><pre><code class="xml"><span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span>
  <span class="tag">&lt;<span class="name">description</span>&gt;</span>jndi data source test<span class="tag">&lt;/<span class="name">description</span>&gt;</span>
  <span class="tag">&lt;<span class="name">res-ref-name</span>&gt;</span>mysql-jndi-test<span class="tag">&lt;/<span class="name">res-ref-name</span>&gt;</span>
  <span class="tag">&lt;<span class="name">res-type</span>&gt;</span>javax.sql.DataSource<span class="tag">&lt;/<span class="name">res-type</span>&gt;</span>
  <span class="tag">&lt;<span class="name">res-auth</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">res-auth</span>&gt;</span>
<span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span>
</code></pre>
<h2 id="程序中引用资源"><a href="#程序中引用资源" class="headerlink" title="程序中引用资源"></a>程序中引用资源</h2><pre><code class="java">DataSource dataSource = <span class="keyword">null</span>;
Statement stmt = <span class="keyword">null</span>;
<span class="keyword">try</span> {
    Context context = <span class="keyword">new</span> InitialContext();
    <span class="comment">//根据资源名称搜索</span>
    dataSource = (DataSource)context.lookup(<span class="string">"java:comp/env/mysql-jndi-test"</span>);
    Connection conn = dataSource.getConnection();
    <span class="comment">//查询</span>
    stmt = conn.createStatement();
    String sql = <span class="string">"SELECT id,phone FROM tbl_user"</span>;
    ResultSet rs = stmt.executeQuery(sql);
    <span class="keyword">while</span>(rs.next()){
        <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);
        String phone = rs.getString(<span class="string">"phone"</span>);
        System.out.print(<span class="string">"ID: "</span> + id);
        System.out.println(<span class="string">", phone: "</span> + phone);
    }
    rs.close();
    stmt.close();
    conn.close();
} <span class="keyword">catch</span> (NamingException e) {
    <span class="comment">// Exception handler</span>
    e.printStackTrace();
} <span class="keyword">catch</span> (SQLException e) {
    e.printStackTrace();
}
</code></pre>
<pre><code class="java">ID: <span class="number">1</span>, phone: <span class="number">18556557289</span>
ID: <span class="number">7</span>, phone: <span class="number">13191512345</span>
ID: <span class="number">8</span>, phone: <span class="number">18909692576</span>
ID: <span class="number">9</span>, phone: <span class="number">15155881028</span>
ID: <span class="number">10</span>, phone: <span class="number">13109170001</span>
ID: <span class="number">11</span>, phone: <span class="number">13109170002</span>
ID: <span class="number">12</span>, phone: <span class="number">13109170003</span>
ID: <span class="number">13</span>, phone: <span class="number">13109170004</span>
ID: <span class="number">14</span>, phone: <span class="number">13109170005</span>
ID: <span class="number">15</span>, phone: <span class="number">15209832896</span>
ID: <span class="number">16</span>, phone: <span class="number">15755179002</span>
ID: <span class="number">17</span>, phone: <span class="number">15209861039</span>
ID: <span class="number">18</span>, phone: <span class="number">18956001364</span>
ID: <span class="number">19</span>, phone: <span class="number">13100001111</span>
ID: <span class="number">20</span>, phone: <span class="number">13200001111</span>
</code></pre>
<h2 id="Spring容器引用资源"><a href="#Spring容器引用资源" class="headerlink" title="Spring容器引用资源"></a>Spring容器引用资源</h2><p>注意，使用<code>Spring</code>容器配置<code>JNDI</code>时不需要配置<code>Web.xml</code>文件。只需要配置<code>spring</code>数据源<code>bean</code>即可。</p>
<pre><code class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jndi.JndiObjectFactoryBean"</span>&gt;</span>
    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jndiName"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">value</span>&gt;</span>java:comp/env/mysql-jndi-test<span class="tag">&lt;/<span class="name">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>
<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>
</code></pre>
<blockquote>
<p>参考: <a href="http://www.cnblogs.com/study-everyday/p/6723313.html" target="_blank" rel="noopener">JNDI是什么，怎么理解</a>  <a href="https://www.ibm.com/developerworks/cn/java/j-jndi/index.html" target="_blank" rel="noopener">JNDI 在 J2EE 中的角色</a>  <a href="http://wiki.jikexueyuan.com/project/tomcat/jdbc-data-sources.html" target="_blank" rel="noopener">极客学院</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jndi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解面向对象]]></title>
      <url>/2017/11/29/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>从接触<code>java</code>语言时，就已经知道了面向对象，对这个概念总是模模糊糊，理解也是零零散散，没有系统的去了解它。面向对象涉及编程思想以及一些方法论，本文不是深入的研究，而是从如下几个方面去理解一下。</p>
</blockquote>
<h1 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h1><p>首先，面向对象是一种软件开发方法，是把构成问题的各个事物分解成各个对象，由各个对象协调解决这个问题或完成这项事务。建立对象的目的不是为了完成一个步骤，而是为了描述一个事物在解决问题的过程中经历的步骤和行为。对象作为程序的基本单位，将程序和数据封装其中，以提高程序的重用性，灵活性和可扩展性。对象之间相互独立而又互相调用。<br><a id="more"></a><br>可以把面向对象的思想和传统的编程思想（面向过程）进行比较加深理解：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”。</p>
<p>举例说明一下，有一天公司老总找到某经理要一分关于某产品的市场调查报告，看看不同的经理是如何处理这件事情的。<br>经理A是一个能力比较强的人，做什么都喜欢亲力亲为，他的处理方式是这样的：</p>
<ul>
<li>第一步，制作市场调查的问题，想好调查的方案，也就是说做好市场调查的准备工作。</li>
<li>第二步，找一天时间去市场上做调查，去那些上一步准备好的地方，问一些准备好的问题并记录。</li>
<li>第三步，把调查的结果记录好后做一些统计，然后形成统计报表。</li>
</ul>
<p>经理B比较笨，不会做报表，市场调查以前也没有接触过，不知道从何下手，于是他找人帮忙：</p>
<ul>
<li>第一步，找到下属同事甲帮忙做一份市场调查的方案。</li>
<li>第二步，按照方案，自己实地调查并记录结果。</li>
<li>第三步，找到同事乙，把自己的记录结果和要求告诉他，要他帮忙做一份统计报表。</li>
</ul>
<p>经理C就非常懒了，但情商比较高，人缘比较好，他找到三个同事帮他完成了这项工作，他告诉同事甲他想要的东西，同事甲做好方案后告诉同事乙要按照方案去做市场调查，同事乙去做了市场调查后再把记录结果交给同事丙。这样经理丙就负责控制进度和把关就行了。</p>
<p>上面的例子中，不同的经理站在不同的角度去思考，最后完成任务的方式也不同。经理A和经理B都是传统的思考方式，按照流程一步一步做，经理B相对轻松，他第一步和第三步交给别人去做，在程序里面相当于写了个函数。经理C就聪明了，把事情交给甲乙丙三个对象，自己关注一下就行。在编程中，面向对象其实就是一种思考方式，这种思考方式可以提高程序的重用性，灵活性和可扩展性。</p>
<h1 id="面向对象概念怎么来的？-背景"><a href="#面向对象概念怎么来的？-背景" class="headerlink" title="面向对象概念怎么来的？(背景)"></a>面向对象概念怎么来的？(背景)</h1><p>早期的计算机编程是基于面向过程的方法，例如实现算术运算<code>1+1+2 = 4</code>，通过设计一个算法就可以解决当时的问题。随着计算机技术的不断提高，计算机被用于解决越来越复杂的问题。通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、继承，帮助人们实现对现实世界的抽象与<strong>数字建模</strong>。通过面向对象的方法，更利于用人理解的方式对复杂系统进行分析、设计与编程。同时，面向对象能<strong>有效提高编程的效率</strong>，通过封装技术，消息机制可以像搭积木的一样快速开发出一个全新的系统。面向对象是指一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的集合。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。</p>
<p>面向对象是在结构化设计方法出现很多问题的情况下应运而生的。结构化设计方法求解问题的基本策略是从功能的角度审视问题域。它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。面对日趋复杂的应用系统，这种开发思路某些方面逐渐暴露了一些弱点。比如说代码的可重用性，灵活性和扩展性等。这种开发思路<strong>增加了程序设计的复杂程度</strong>，而且<strong>背离了人们观察问题和解决问题的基本思路</strong>。使得应用程序的<strong>日后维护和扩展相当困难</strong>，甚至一个微小的变动，都会波及到整个系统。</p>
<h1 id="面向对象的一些优势"><a href="#面向对象的一些优势" class="headerlink" title="面向对象的一些优势"></a>面向对象的一些优势</h1><p>面向对象的优势是相对于传统方式来讲的。</p>
<ul>
<li>代码重用性高。</li>
<li>代码更加灵活。</li>
<li>扩展性强，便于日后维护和扩展。</li>
<li>更加贴近人们观察问题和解决问题的基本思路，可读性强。</li>
</ul>
<h1 id="面向对象的一些概念"><a href="#面向对象的一些概念" class="headerlink" title="面向对象的一些概念"></a>面向对象的一些概念</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是一个模板，它描述一类对象的行为和状态。对象是类的一个实例，有具体的状态和行为。比如狗是一个类，有大小、体重、毛色等状态，也有叫、跑等行为，他是一类对象（比如说二哈、阿拉斯加等）的模板，而对象指的是一个具体的狗，比如说你的宠物犬，它是白色的，体重30公斤等，叫起来像狼，跑起来疯疯癫癫的。</p>
<h2 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h2><p>通俗的来讲，就是自己的东西自己保管，自己的事情自己做，只对外展现出状态和行为。就是封装的体现，程序 = 数据结构 + 算法。</p>
<h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>在面向对象编程中，对象自身是内聚的，是保管好自己的数据，完成好自己的操作的，而对外界呈现出自己的状态和行为。但是，没有绝对的自力更生，对外开放也是必要的！一个对象，往往需要跟其他对象打交道，既包括获知其他对象的状态，也包括仰赖其他对象的行为，而一旦这样的事情发生时，我们便称该对象依赖于另一对象。只要两个对象之间存在一方依赖一方的关系，那么我们就称这两个对象之间存在耦合。比如妈妈和baby，妈妈要随时关注baby的睡、醒、困、哭、尿等等状态，baby则要仰赖妈妈的喂奶、哄睡、换纸尿裤等行为，从程序的意义上说，二者互相依赖，因此也存在耦合。首先要说，耦合是必要的,但程序耦合度越高越不灵活。</p>
<h1 id="面向对象主要特征"><a href="#面向对象主要特征" class="headerlink" title="面向对象主要特征"></a>面向对象主要特征</h1><p>面向对象三大特征，封装、继承与多态。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装也称为信息隐藏,是指利用抽象数据类型将数据和基于数据的操作封 装在一起,使其构成一个不可分割的独立实体,数据被保护在抽象数据类型的内部,尽可能地隐藏内部的细节,只保留一些对外接口使之与外部发生联系。系统的其他部分只有通过包裹在数据外面的被授权的操作来与这个抽象数据类型交流与交互。也就是说,用户无需知道对象内部方法的实现细节,但可以根据对象提供的外部接口(对象名和参数)访问该对象。<br>好处:</p>
<ol>
<li>实现了专业的分工。将能实现某一特定功能的代码封装成一个独立的实体后,各程序员可以在需要的时候调用,从而实现了专业的分工。</li>
<li>隐藏信息,实现细节。通过控制访问权限可以将可以将不想让客户端程序员看到的信息 隐藏起来,如某客户的银行的密码需要保密,只能对该客户开发权限。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。要实现继承，可以通过“继承”（<code>Inheritance</code>）和“组合”（<code>Composition</code>）来实现。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式事务管理]]></title>
      <url>/2017/11/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这是同事在分享会上整理的资料，收获颇丰。</p>
<p>事务管理<br>    几乎所有的Web项目中都会涉及数据库，那么当多个客户行为同时操作到了一条或一批数据时，就有可能因这种并发操作导致他们之间相互产生影响而导致错误的结果。本文将详细介绍这些问题产生的过程以及如何解决这些问题。</p>
</blockquote>
<a id="more"></a>
<h1 id="共享资源与并发"><a href="#共享资源与并发" class="headerlink" title="共享资源与并发"></a>共享资源与并发</h1><p>什么是共享资源？</p>
<blockquote>
<p>共享资源指的是可以被多个任务同时使用的资源，在本文中，我们的共享资源指的是数据库、表以及表中的记录。<br>当程序并发操作同一条或同一批记录时，可能会发生以下四种并发问题。</p>
</blockquote>
<ul>
<li>更新丢失（<code>Lost Update</code>）</li>
<li>脏读（<code>Dirty Reads</code>）</li>
<li>不可重复读（<code>Non-repeatable Reads</code>）</li>
<li>幻象读（<code>Phantom Reads</code>）</li>
</ul>
<h2 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h2><p>如下图所示，程序<code>X</code>对记录<code>A</code>更新后又被程序Y覆盖，导致程序<code>X</code>的更新丢失，我们称这样的意外为<strong>更新丢失</strong>。<br><img src="lostUpdate.png" alt="更新丢失"></p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>如下图所示，程序<code>X</code>先对记录<code>A</code>进行了更新后，程序Y从数据库内存中读取了更新的记录<code>A</code>，但接下来由于程序<code>X</code>发生了一些异常导致对记录<code>A</code>的更新被回滚了，因此记录<code>Y</code>读取的就是一条脏记录，我们称这种意外为<strong>脏读</strong>。<br><img src="dirtyReads.png" alt="脏读"></p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>如下图所示，程序<code>X</code>先读取了记录<code>A</code>后，程序<code>Y</code>更新了<code>A</code>记录并进行了提交，由于业务需要程序<code>X</code>又再次从数据库中读取了<code>A</code>记录，按程序的设想两次读取的记录应该是一致的，但由于执行过程中程序<code>Y</code>的更新操作导致两次读取的信息不一致，我们称这种意外为<strong>不可重复读</strong>。<br><img src="nonRepeatableReads.png" alt="不可重复读"></p>
<h2 id="幻象读"><a href="#幻象读" class="headerlink" title="幻象读"></a>幻象读</h2><p>如下图所示，程序<code>X</code>从表中批量读取了记录<code>A</code>后，程序<code>Y</code>对表中进行了<code>insert</code>或<code>delete</code>操作，由于业务需要程序<code>X</code>又再次从数据库中批量读取了<code>A</code>记录，按程序的设想两次读取的记录数量应该是一致的，但由于执行过程中程序<code>Y</code>的<code>insert/delete</code>操作导致两次读取的记录数量不一致，我们称这种意外为<strong>幻象读</strong>。<br><img src="phantomReads.png" alt="幻象读"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务(<code>Transaction</code>)是访问并可能更新数据库中各种数据项的一个程序执行单元(<code>unit</code>)，通俗的说，事务就是由一到多条<code>sql</code>组成的一个不可分割的操作单元。</p>
<h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><ul>
<li>原子性（<code>Atomicity</code> ）<br>事务是不可拆分的执行单元，要么都执行，要么都不执行。</li>
<li>一致性（ <code>Consistency</code> ）<br>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</li>
<li>隔离性（ <code>Isolation</code> ）<br>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（ <code>Durability</code> ）<br>事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<h2 id="衡量并发事务正确执行的标准是什么？"><a href="#衡量并发事务正确执行的标准是什么？" class="headerlink" title="衡量并发事务正确执行的标准是什么？"></a>衡量并发事务正确执行的标准是什么？</h2><p>可串行性，即并发执行的事务与多个事务的某个串行执行的结果一致，我们称此为并发事务的可串行性，这是衡量并发事务是否正确执行的唯一标准。</p>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="排它锁与共享锁"><a href="#排它锁与共享锁" class="headerlink" title="排它锁与共享锁"></a>排它锁与共享锁</h2><p>事务的可串行性需要排它锁和共享锁提供保障：</p>
<ul>
<li>排它锁(<code>eXclusive lock</code>,简记为<code>X</code>锁)<br>排它锁又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。</li>
<li>共享锁（<code>Share lock</code>,简记为<code>S</code>锁）<br>共享锁又称为读锁，若事务<code>T</code>对数据对象<code>A</code>加上<code>S</code>锁，则其它事务只能再对<code>A</code>加<code>S</code>锁，而不能加<code>X</code>锁，直到<code>T</code>释放<code>A</code>上的<code>S</code>锁。</li>
</ul>
<h2 id="事务一致性解决方案"><a href="#事务一致性解决方案" class="headerlink" title="事务一致性解决方案"></a>事务一致性解决方案</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>修改数据前锁定记录，阻止其他线程访问。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。悲观锁主要用于以下两种环境：</p>
<ul>
<li>资源竞争激烈的环境</li>
<li>发生并发冲突时采用回滚机制耗费的成本比用锁保护数据成本高的环境</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>事务在<code>commit</code>时进行检查，如果当前事务所处理的数据在事务<code>begin</code>到<code>commit</code>之间被其他事务修改过，那么就会就会产生一个错误，并对当前事务进行的操作进行<code>rollback</code>，否则进行<code>commit</code>操作。乐观锁主要用于以下两种环境：</p>
<ul>
<li>资源竞争少的环境</li>
<li>不出现或者偶尔出现回滚事务的成本高于read数据时锁定数据的成本的环境</li>
</ul>
<h3 id="时标控制"><a href="#时标控制" class="headerlink" title="时标控制"></a>时标控制</h3><p>事务在启动时设定一个时间戳，然后在每个操作执行前都进行验证：如果当前操作对应的资源的被其他事务进行最后一次<code>read</code>或<code>write</code>并<code>commit</code>的时间戳大于当前事务开始的时间戳，那么就放弃当前事务并进行<code>rollback</code>，然后再由客户重新启动事务。这就意味着，当前事务启动后，若被操作的资源被其他事务<code>read</code>或<code>write</code>并<code>commit</code>后就直接放弃再重新启动事务，直到新的时间戳能够满足条件。</p>
<h3 id="锁协议"><a href="#锁协议" class="headerlink" title="锁协议"></a>锁协议</h3><p>除了以上三种解决方案，还有一些协议可以在不同程度上为并发操作提供保障，主要有三阶段封锁协议与两段封锁协议。</p>
<ul>
<li>三级封锁协议（也称为三级加锁协议）<ul>
<li>一级封锁： 事务在修改资源前先为资源添加排它锁，直到事务结束时才释放此资源，此封锁可以解决更新丢失问题。</li>
<li>二级封锁： 在一级封锁的基础上，遇到事务读取资源的情况，那么在事务读取资源前添加共享锁，读完后立即释放资源，此封锁可以解决更新丢失和脏读问题。</li>
<li>三级封锁： 在一级封锁的基础上，遇到事务读取资源的情况，那么在事务读取资源前添加共享锁，知道事务结束后才释放资源，此封锁可以解决更新丢失、脏读、 不可重复读以及幻想读问题。</li>
</ul>
</li>
<li>两段锁协议<br>此协议将事务分为两个阶段：<ul>
<li>第一阶段： 资源上锁阶段，对事务中所有涉及的资源在read/write之前进行上锁操作。</li>
<li>第二阶段： 资源释放阶段，一旦事务释放了第一个资源，那么当前事务此后将不再进行任何封锁操作，只进行解锁对资源进行释放的操作。如果并行执行的所有事务均遵守两段锁协议，那么他们的并行调度具有可串行性。</li>
</ul>
</li>
</ul>
<h2 id="封锁后遗症"><a href="#封锁后遗症" class="headerlink" title="封锁后遗症"></a>封锁后遗症</h2><p>使用封锁技术可以从不同程度上解决事务的一致性问题，但封锁技术同时也会带来一些后遗症，主要有活锁和死锁。</p>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>事务<code>T1</code>封锁了对象<code>A</code>后，事务<code>T2</code>请求封锁对象<code>A</code>，于是<code>T2</code>进行等待，接着<code>T3</code>也请求封锁对象<code>A</code>，<code>T3</code>等待，当<code>T1</code>释放了<code>A</code>以后，系统如果先批准了<code>T3</code>对<code>A</code>的封锁请求，那么<code>T2</code>继续等待，接着可能有<code>T4</code>、<code>T5</code>…，如果系统一直未批<code>T2</code>的请求，那么<code>T2</code>就一直无法执行，这就造成了“活锁”。如何避免活锁？采用先来先服务策略。</p>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>如下图所示，线程<code>X</code>和线程<code>Y</code>都需要资源<code>A</code>和<code>B</code>，如果<code>X</code>先锁定了<code>A</code>，<code>Y</code>先锁定了<code>B</code>，那么<code>X</code>就会等待<code>Y</code>释放资源<code>B</code>，<code>Y</code>同时也在等待<code>X</code>释放<code>A</code>，这样就会无限等待下去而造成“死锁”。<br><img src="deadLock.png" alt="死锁"></p>
<h3 id="如何解决死锁问题呢？"><a href="#如何解决死锁问题呢？" class="headerlink" title="如何解决死锁问题呢？"></a>如何解决死锁问题呢？</h3><p>操作系统一般采用一次封锁所有资源的方式，但这样大大限制了并发，所以<code>DBMS</code>采用了诊断并解除死锁的方式，即每隔一个时间片段机会检测是否存在死锁，如果存在，那么就会选择撤销代价小的事务进行回滚，让撤销代价大的事务执行。</p>
<h2 id="嵌套事务管理"><a href="#嵌套事务管理" class="headerlink" title="嵌套事务管理"></a>嵌套事务管理</h2><p>锁的获取与释放规则：</p>
<ul>
<li>规则1：如果子事务获取了某条数据的读锁，那么只有其父事务可以对该对象添加写锁；</li>
<li>规则2：如果子事务获取了某条数据的写锁，那么只有其父事务可以持有该写锁，以及添加读锁；</li>
<li>规则3：当子事务<code>commit</code>时，它所有的锁由其父事务保留；</li>
<li>规则4：当子事务放弃时，它所有的锁将被放弃，如果其父事务已经获取了这些锁，那么它可以继续保留；</li>
</ul>
<p>并行调度规则：</p>
<ul>
<li>规则1：父事务不允许和子事务并发运行；</li>
<li>规则2：同层次的子事务可以并发运行；</li>
</ul>
<p><code>commit</code>和<code>rollback</code>规则：</p>
<ul>
<li>规则1：子事务执行前会为父事务设定一个状态，如果子事务失败，那么所涉及到的父事务中的对象将被回滚到设定的状态；</li>
<li>规则2：子事务是父事务的一部分，只有当顶级的事务<code>commit</code>时，所有的子事务才会<code>commit</code>，如果父事务<code>rollback</code>，那么所有的子孙事务也会<code>rollback</code>。</li>
</ul>
<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><p> 数据库隔离级别:数据库设定满足项目需求的隔离级别，设置的隔离级别越高，数据出现不一致性的可能越小，但这同时也会降低数据库并发访问的数量而降低性能。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">避免覆盖更新</th>
<th style="text-align:center">避免脏读</th>
<th style="text-align:center">避免不可重复读</th>
<th style="text-align:center">避免幻读</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Read uncommitted</code> (读未提交)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td></td>
</tr>
<tr>
<td><code>Read committed</code> (读已提交)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td><code>Oracle</code>默认级别</td>
</tr>
<tr>
<td><code>Repeatable read</code> (可重复读)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td><code>MySql</code>默认级别</td>
</tr>
<tr>
<td><code>Serializable</code> (串行化)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p><code>MySql</code>隔离级别操作示例：</p>
<ul>
<li>操作一：查看当前会话隔离级别<br><code>select @@tx_isolation;</code></li>
<li>操作二：查看系统当前隔离级别<br><code>select @@global.tx_isolation;</code></li>
<li>操作三：设置当前会话隔离级别<br><code>set session transaction isolatin level repeatable read;</code></li>
<li>操作四：设置系统当前隔离级别<br><code>set global transaction isolation level repeatable read;</code></li>
</ul>
<p>在<code>MySql</code>中查询出的默认隔离级别：<br><img src="global_tx_isolation.png" alt="隔离级别"></p>
<h1 id="Web项目事务管理"><a href="#Web项目事务管理" class="headerlink" title="Web项目事务管理"></a>Web项目事务管理</h1><p>本小节将介绍事务在项目中的实际应用，并且只说明了一些经常使用的场景。</p>
<h2 id="Spring-Hibernate声明式事务"><a href="#Spring-Hibernate声明式事务" class="headerlink" title="Spring + Hibernate声明式事务"></a>Spring + Hibernate声明式事务</h2><p><img src="spring-hibernate-tx.png" alt="spring-hibernate声明式事务管理"><br>上图是<code>spring-hibernate</code>声明式事务管理声明式事务指的是在配置文件中声明。用在<code>Spring</code>配置文件中声明式的处理事务来代替代码式的处理事务。这样的好处是，事务管理不侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可；在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便，因此这也是我们项目中的第一选择。<br><code>Spring</code>使用<code>AOP</code>来完成声明式的事务管理，因而声明式事务是以方法为单位，<code>Spring</code>的事务属性自然就在于描述事务应用至方法上的策略，在<code>Spring</code>中事务属性有以下参数:</p>
<ul>
<li><code>name</code>，方法名称，可以使用方法全名，也可以使用<code>Spring</code>的表达式，我们一般使用<code>spring</code>表达式来对方法进行匹配，因此我们的方法命名也必须符合要求才能启动事务管理。</li>
<li><code>propagation</code>，事务传播行为，<code>Hibernate</code>设定了7种事务传播行为，如下表所示：<ul>
<li><code>PROPAGATION_REQUIRED</code>:对应配置中的<code>REQUIRED</code>，如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中,这是最常见的选择 </li>
<li><code>PROPAGATION_SUPPORTS</code>:对应配置中的<code>SUPPORTS</code>，支持当前事务，如果当前没有事务，就以非事务方式执行</li>
<li><code>PROPAGATION_MANDATORY</code>:对应配置中的<code>MANDATORY</code>，使用当前的事务，如果当前没有事务，就抛出异常</li>
<li><code>PROPAGATION_REQUIRES_NEW</code>:应配置中的<code>REQUIRES_NEW</code>，新建事务，如果当前存在事务，把当前事务挂起</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code>:对应配置中的<code>NOT_SUPPORTED</code>，以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li><code>PROPAGATION_NEVER</code>:对应配置中的<code>NEVER</code>，以非事务方式执行，如果当前存在事务，则抛出异常</li>
<li><code>PROPAGATION_NESTED</code>:对应配置中的<code>NESTED</code>，如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类 似的操作</li>
</ul>
</li>
<li><code>isolation</code>，事务隔离级别，对应到数据库隔离级别，此参数为非强制选项，默认值为<code>DEFAULT</code>，即根据系统选用的数据库自动使用数据库默认的事务隔离级别，例如<code>MySql</code>自动使用<code>REPEATABLE_READ</code>。<ul>
<li><code>DEFAULT</code>:数据库默认级别</li>
<li><code>READ_UNCOMMITTED</code>:读未提交</li>
<li><code>READ_COMMITTED</code>:读已提交</li>
<li><code>REPEATABLE_READ</code>:可重复读</li>
<li><code>SERIALIZABLE</code>:串行化</li>
</ul>
</li>
<li><code>readonly</code>，用于设定当前事务是否只读事务，此参数为非强制选项，它默认为<code>false</code>，如果确定为只读事务，那么可以设定为<code>true</code>。</li>
<li><code>timeout</code>，用于设定事务超时时间（单位：秒），此参数为非强制选项，它的默认值为<code>-1</code>，表示没有时间限制，如果系统对时间要求比较明确，那么可以设定一个固定值。</li>
<li><code>rollback-for</code>，用于设定与到哪些异常时进行事务回滚操作，我们的项目中遇到所有类型的异常都将回滚，所以我们配置的是 <code>rollback-for=&quot;java.lang.Throwable&quot;</code>。</li>
<li><p><code>no-rollback-for</code>，与<code>rollback-for</code>对应的还有<code>no-rollback-for</code>,此参数可以从<code>rollback-for</code>范围内排除不需要进行回滚的异常。</p>
<h2 id="Spring-Hibernate-注解式事务"><a href="#Spring-Hibernate-注解式事务" class="headerlink" title="Spring + Hibernate 注解式事务"></a>Spring + Hibernate 注解式事务</h2><p>除了声明式事务管理，<code>spring</code>也为我们提供了注解式事务管理，我们可以在类以及方法上使用注解来管理事务。例如：</p>
<pre><code class="java"><span class="meta">@Transactional</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceBean</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>{
  <span class="keyword">private</span> TestDao dao;

  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(TestDao dao)</span> </span>{
      <span class="keyword">this</span>.dao = dao;
  }

  <span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)
  <span class="function"><span class="keyword">public</span> List <span class="title">getAll</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">null</span>;
  }
}
</code></pre>
<p><code>@Transactional</code>可以配置在类或方法上，如果类和方法上都配置了，那么方法中的配置会覆盖类的全局配置，此注解的参数与声明式配置中的参数基本一致，这里不再做详细说明。</p>
<h2 id="Hibernate锁模式"><a href="#Hibernate锁模式" class="headerlink" title="Hibernate锁模式"></a>Hibernate锁模式</h2><p><code>Hibernate</code>的悲观锁机制完全依赖<code>JDBC</code>连接或<code>JTA</code>资源实现，<code>Hibernate</code>不能在<code>Session</code>缓存中加任何锁，只能为<code>JDBC</code>连接设置隔离级别。但乐观锁就要灵活的多，除了可以通过声明式事务管理和注解式事务管理外，我们还可以在代码中控制锁的细节。这主要通过<code>Hibernate</code>中的<code>LockMode</code>来控制。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th style="text-align:center">可用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NONE</code></td>
<td style="text-align:center">×</td>
<td>无锁机制，<code>Hibernate</code>默认采用此模式，仅供<code>Hibernate</code>内部使用</td>
</tr>
<tr>
<td><code>WRITE</code></td>
<td style="text-align:center">×</td>
<td>在 <code>Insert</code> 和 <code>Update</code> 记录的时候会自动获取，仅供<code>Hibernate</code>内部使用</td>
</tr>
<tr>
<td><code>READ</code></td>
<td style="text-align:center">×</td>
<td>在读取记录的时候会自动获取，仅供<code>Hibernate</code>内部使用</td>
</tr>
<tr>
<td><code>FORCE</code></td>
<td style="text-align:center">×</td>
<td><code>@Deprecated</code>，被<code>PESSIMISTIC_FORCE_INCREMENT</code>替代</td>
</tr>
<tr>
<td><code>PESSIMISTIC_FORCE_INCREMENT</code></td>
<td style="text-align:center">√</td>
<td>强制更新数据库中对象的版本属性,即表明当前事务已经更新了这个对象（事务尚未提交）</td>
</tr>
<tr>
<td><code>UPGRADE</code></td>
<td style="text-align:center">×</td>
<td><code>@Deprecated</code>，被<code>PESSIMISTIC_WRITE</code>替代</td>
</tr>
<tr>
<td><code>PESSIMISTIC_READ</code></td>
<td style="text-align:center">√</td>
<td>悲观锁，即利用数据库的<code>for update</code>字句加锁，事务开始即获得数据库的锁。</td>
</tr>
<tr>
<td><code>PESSIMISTIC_WRITE</code></td>
<td style="text-align:center">√</td>
<td>悲观锁，即利用数据库的<code>for update</code>字句加锁，事务开始即获得数据库的锁。</td>
</tr>
<tr>
<td><code>PESSIMISTIC_FORCE_INCREMENT</code></td>
<td style="text-align:center">√</td>
<td>悲观锁，且强制更新版本属性</td>
</tr>
<tr>
<td><code>OPTIMISTIC</code></td>
<td style="text-align:center">√</td>
<td>乐观锁</td>
</tr>
<tr>
<td><code>OPTIMISTIC_FORCE_INCREMENT</code></td>
<td style="text-align:center">√</td>
<td>乐观锁，且强制更新版本属性</td>
</tr>
<tr>
<td><code>UPGRADE_NOWAIT</code></td>
<td style="text-align:center">√</td>
<td>Oracle 的特定实现，利用 <code>Oracle</code> 的 <code>for update nowait</code> 子句实现加锁</td>
</tr>
<tr>
<td><code>UPGRADE_SKIPLOCKED</code></td>
<td style="text-align:center">√</td>
<td><code>Oracle</code>应用的查询请求使用<code>SELECT ... for update skip</code></td>
</tr>
</tbody>
</table>
<p>版本属性，即通过<code>@Version</code>来标记的属性，<code>JPA</code>通过实体类中使用<code>@Version</code>注解来发现数据库记录的并发操作，当有个记录更新了（事务尚未提交）该记录时就表明此记录已经被更新，其他并发操作试图操作此记录时就抛出异常<code>OptimisticLockException</code>。<br><code>Hibernate</code>中可以在<code>Query.setLockMode</code>、<code>Session.lock</code>、<code>Session.get</code>、<code>Session.find</code>以及<code>Criteria.setLockMode</code>等操作中设定锁模式。另外需要注意的是，需要与<code>LockModeType</code>进行区分，<code>LockModeType</code>也有类似的功能，但仅用于<code>java</code>持久化查询语言（<code>JPQL</code>）或<code>Criteria API</code>查询，否则会抛异常。</p>
<h1 id="分布式事务管理"><a href="#分布式事务管理" class="headerlink" title="分布式事务管理"></a>分布式事务管理</h1><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>分布式系统是指软件被拆分成多个组件，并分布在不同的网算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。<br>常见的分布式方案有以下几种：</p>
<ul>
<li>分布式存储<br>大型网站常常需要处理海量数据，单台计算机往往无法提供足够的内存空间，可以对这些数据进行分布式存储。</li>
<li>分布式服务<br>将应用和服务进行分层和分割，然后将应用和服务模块进行分布式部署。这样做不仅可以提高并发访问能力、减少数据库连接和资源消耗，还能使不同应用复用共同的服务，使业务易于扩展。</li>
<li>分布式静态资源<br>对网站的静态资源如<code>JS</code>、<code>CSS</code>、图片等资源进行分布式部署可以减轻应用服务器的负载压力，提高访问速度。</li>
<li>分布式计算<br>随着计算技术的发展，有些应用需要非常巨大的计算能力才能完成，如果采用集中式计算，需要耗费相当长的时间来完成。分布式计算将该应用分解成许多小的部分，分配给多台计算机进行处理。这样可以节约整体计算时间，大大提高计算效率。</li>
</ul>
<p>和集中式系统相比，分布式系统的性价比更高、处理能力更强、可靠性更高、也有很好的扩展性。但是，分布式在解决了网站的高并发问题的同时也带来了一些其他问题，其中分布式存储和服务带来的数据一致性就是其中典型的一个问题。在介绍分布式的数据一致性之前，需先向大家介绍下远程通信方式和语义以及幂等性的概念。</p>
<h3 id="远程通信方式"><a href="#远程通信方式" class="headerlink" title="远程通信方式:"></a>远程通信方式:</h3><ul>
<li>远程过程调用:<code>Remote Procedure Call</code>，简称<code>RPC</code>，例如，我们使用<code>cxf</code>、<code>dubbo</code>等框架采用的就是此通信方式</li>
<li>远程方法调用:<code>Remote Method Invocation</code>，简称<code>RMI</code>，这是<code>java</code>平台特有的一种通信方式，使用的较少</li>
<li>消息队列调用:<code>Message Queue</code>,简称<code>MQ</code>，此方式常使用<code>RabbitMQ</code>、<code>ActiveMQ</code>、<code>ZeroMQ</code>等消息中间件进行消息的传递与应答，避免生产者与消费者直接接触，此方式可以避免消息丢失，同时可以对系统某时间段访问请求过多起缓冲作用</li>
</ul>
<h3 id="远程通信语义"><a href="#远程通信语义" class="headerlink" title="远程通信语义:"></a>远程通信语义:</h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>或许</td>
<td>远程方法可能执行一次，也可能不执行</td>
<td>消息丢失或服务崩溃</td>
</tr>
<tr>
<td>最少一次</td>
<td>调用者知道最少调用了一次或者未接受到执行结果（接受到异常）</td>
<td>重复调用幂等性的服务或服务异常</td>
</tr>
<tr>
<td>最多一次</td>
<td>调用者知道最多调用了一次或者未接受到执行结果（接受到异常）</td>
<td>有效防止因非幂等性而导致的随机故障</td>
</tr>
</tbody>
</table>
<p>分布式通信根据自己的需要可以选择不同的语义，下表根据分布式对请求重发、过滤、重新执行以及应答等问题给出了通信语义的方案。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>请求重发</th>
<th>过滤重复请求</th>
<th>重新执行或重传应答</th>
</tr>
</thead>
<tbody>
<tr>
<td>或许</td>
<td>否</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>最少一次</td>
<td>是</td>
<td>否</td>
<td>重新执行</td>
</tr>
<tr>
<td>最多一次</td>
<td>是</td>
<td>是</td>
<td>重传应答</td>
</tr>
</tbody>
</table>
<h3 id="什么是方法的幂等性？"><a href="#什么是方法的幂等性？" class="headerlink" title="什么是方法的幂等性？"></a>什么是方法的幂等性？</h3><p>方法的幂等性指的是此方法任意多次执行所产生的影响均与一次执行的影响相同。</p>
<p>保证分布式服务的幂等性是分布式架构中的一个重要指标。有些方法本身就具有幂等性,例如，将订单更新为待支付状态。更多的方法是不具有幂等性的，例如，订单支付方法。假设系统有订单服务和支付服务，付款时，订单服务就需要调用支付服务的支付方法，如果订单服务发送支付请求成功，支付服务也如预期的那样支付完成了，但支付服务在向订单服务反馈时出现了网络故障，导致订单服务支付出现异常，此时如果系统有重复调用的机制，那么就需要确保再次调用支付服务是不会出现重复支付的情况，因此我们就需要通过其他方式来确保此支付方法具有幂等性效果（伪幂等性）。</p>
<p>通过完成以下工作就可以让非幂等性方法具有幂等性效果：</p>
<ul>
<li>构建一个全局的服务不重复请求序号生成器</li>
<li>跨服务请求前要生成一个请求序号并传递给被请求的服务</li>
<li>非幂等性的服务方法在执行成功后保存执行结果</li>
<li>重复访问服务时需带上第一次访问时生成的请求序号</li>
<li>服务被访问时，通过请求序号验证是否已访问并有执行结果，如果是，那么直接返回执行结果，否则执行业务、保存执行结果并返回</li>
</ul>
<h2 id="可靠事件模式"><a href="#可靠事件模式" class="headerlink" title="可靠事件模式"></a>可靠事件模式</h2><p>此模式属于事件驱动架构，当某件重要事情发生时，例如创建订单，微服务会向消息代理发布一个订单支付事件。消息代理会向订阅事件的微服务推送事件，当订阅这些事件的微服务接收此事件时，就可以完成自己的业务，同时此业务也可能会发布其他的事件。</p>
<p>可靠事件模式在于保证可靠事件投递和避免重复消费，可靠事件投递需要保证每个服务原子性的业务操作和发布事件，以及确保事件传递至少一次。这些我们需要借助消息代理（<code>Message Broker</code>）来完成，现在一些流行<code>MQ</code>，例如<code>ActiveMQ</code>、<code>RabbitMQ</code>等都支持消息的持久化，以及最少一次语义模式。避免重复消费则需要确保服务的幂等性。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span></span>{
    <span class="keyword">try</span>{
        <span class="comment">//1、操作数据库</span>
        <span class="keyword">boolean</span> result = dao.update(model);<span class="comment">//操作数据库失败会抛出异常</span>

        <span class="comment">//2、如果第一步成功，则投递消息。</span>
        <span class="keyword">if</span> (result) {
            mq.append(model);<span class="comment">//如果投递消息失败，方法会抛出异常</span>
        }    
    } <span class="keyword">catch</span>(Exception ex) {
        rollback();<span class="comment">//异常回滚</span>
    }
}
</code></pre>
<p>根据上述代码及注释，初看可能出现 3 种情况:</p>
<ul>
<li>操作数据库成功，向消息代理投递事件也成功。</li>
<li>操作数据库失败，不会向消息代理中投递事件了。</li>
<li>操作数据库成功，但是向消息代理中投递事件时失败，向外抛出了异常，刚刚执行的更新数据库的操作将被回滚。 </li>
</ul>
<p>从上面分析的几种情况来看，貌似没有问题。但是仔细分析不难发现缺陷所在，在上面的处理过程中存在一段隐患时间窗口。<br><img src="xlt_01.png" alt="服务序列1"><br>服务 <code>A</code> 投递事件的时候可能消息代理已经处理成功，但是返回响应的时候网络异常，导致 <code>append</code> 操作抛出异常。最终结果是事件被投递，数据库却被回滚。<br><img src="xlt_02.png" alt="服务序列2"><br>在投递完成后到数据库 <code>commit</code> 操作之间如果微服务 <code>A</code> 宕机也将造成数据库操作因为连接异常关闭而被回滚。最终结果还是事件被投递，数据库却被回滚。这个实现往往运行很长时间都没有出过问题，但是一旦出现了将会让人感觉莫名，很难发现问题所在。</p>
<p>下面给出两种可靠事件投递的实现方式。</p>
<h3 id="本地事件表"><a href="#本地事件表" class="headerlink" title="本地事件表"></a>本地事件表</h3><p>本地事件表方法将事件和业务数据保存在同一个数据库中，使用一个额外的“事件恢复”服务来恢复事件，由本地事务保证更新业务和发布事件的原子性。考虑到事件恢复可能会有一定的延时，服务在完成本地事务后可立即向消息代理发布一个事件。</p>
<ul>
<li>服务在同一个本地事务记录业务数据和事件</li>
<li>服务实施发布一个事件立即通知关联业务服务，如果事件发布成功立刻删除记录的事件</li>
<li>事件恢复服务定时从事件表中恢复未发布成功的事件，重新发布成功后删除记录的事件</li>
</ul>
<p>本地事件表方式有比较明显的缺陷，例如会导致业务系统和事件系统耦合紧密，额外的事件操作也会给数据库带来压力。</p>
<h3 id="外部事件表"><a href="#外部事件表" class="headerlink" title="外部事件表"></a>外部事件表</h3><p>外部事件表方法将事件持久化到外部的事件系统，事件系统需提供实时事件服务以接受微服务发布事件，同时事件系统还需要提供事件恢复服务来确认和恢复事件。</p>
<ul>
<li>业务服务在事务提交前，通过实时事件服务向事件系统请求发送事件，事件系统只记录事件并不真正发送。</li>
<li>业务服务在提交后，通过实时事件服务向事件系统确认发送，事件得到确认后事件系统才真正发布事件到消息代理。</li>
<li>业务服务在业务回滚时，通过实时事件向事件系统取消事件。</li>
<li>如果业务服务在发送确认或取消之前停止服务了怎么办呢？事件系统的事件恢复服务会定期找到未确认发送的事件向业务服务查询状态，根据业务服务返回的状态决定事件是要发布还是取消。</li>
</ul>
<p>该方式将业务系统和事件系统独立解耦，都可以独立伸缩。但是这种方式需要一次额外的发送操作，并且需要发布者提供额外的查询接口。</p>
<h2 id="业务补偿模式"><a href="#业务补偿模式" class="headerlink" title="业务补偿模式"></a>业务补偿模式</h2><p>补偿模式使用一个额外的协调服务来协调各个需要保证一致性的服务，协调服务按顺序调用各个服务，如果某个服务调用异常（包括业务异常和技术异常）就通过执行与业务方法对应的补偿过程取消之前所有已经调用成功的服务。补偿模式建议仅用于不能避免出现业务异常的情况，如果有可能应该优化业务模式，以避免要求补偿事务。如账户余额不足的业务异常可通过预先冻结金额的方式避免，商品库存不足可要求商家准备额外的库存等。</p>
<p>对于一个通用的补偿框架来说，预先知道服务需要记录的业务要素是不可能的，因此我们就需要通过设计一些表来记录所有业务执行的流水。补偿过程作为一个服务调用过程同样存在调用不成功的情况，这个时候需要通过重试的机制来保证补偿的成功率。当然这也就要求补偿操作本身具备幂等性。</p>
<h2 id="两阶段提交模式"><a href="#两阶段提交模式" class="headerlink" title="两阶段提交模式"></a>两阶段提交模式</h2><p><code>Two Phrase Commit Protocol</code>，简称<code>2PC</code>，翻译成中文即“两阶段提交协议”，这是处理分布式事务的最常见协议。<br>在此协议中，一个或多个资源管理器的活动均由一个称为事务管理器的应用组件来控制。此协议分为两个阶段：</p>
<ul>
<li>投票阶段:<br>事务管理器给每个参与者(资源管理器)发送<code>Prepare</code>消息，参与者执行事务<code>commit</code>前的准备工作（例如，执行业务并将结果写如本地的<code>redo</code>和<code>undo</code>日志），根据自身的情况判断是否允许<code>commit</code>并向事务管理器发起投票。</li>
<li>提交阶段:<br>只要事务管理器在规定时间内未收到所有投票或者其中有一个反对票，那么它将给每个参与者发送回滚(<code>Rollback</code>)消息或者不发送让各参与者超时自动<code>rollback</code>，否则，它将发送提交(<code>Commit</code>)消息，参与者根据事务管理器的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。</li>
</ul>
<p>基于<code>2PC</code>，我们常见的有以下两种分布式事务处理方案，他们分别<code>XA模式</code>和<code>TCC模式</code>，其中<code>XA模式</code>用于解决分布式存储的数据一致性问题，<code>TCC</code>用于解决分布式服务的数据一致性问题。</p>
<h3 id="XA模式（数据库2PC）"><a href="#XA模式（数据库2PC）" class="headerlink" title="XA模式（数据库2PC）"></a>XA模式（数据库2PC）</h3><p><code>XA</code>协议由<code>Tuxedo</code>首先提出的，并交给<code>X/Open</code>组织，作为资源管理器（数据库）与事务管理器的接口标准。目前，<code>Oracle</code>、<code>Informix</code>、<code>DB2</code>、<code>Sybase</code>和<code>MySql</code>等各大数据库厂家都提供对<code>XA</code>的支持。<code>XA</code>协议采用<code>2PC</code>的方式来管理分布式事务。<code>XA</code>接口提供资源管理器与事务管理器之间进行通信的标准接口。</p>
<p><code>JTA</code>是<code>Java Transaction API</code>简称，即<code>Java</code>事务管理器规范，主要用于管理本地事务，如果想让<code>JTA</code>管理多台数据库操作的分布式事务，那么就需要<code>XA</code>支持。需要注意的是，<code>Spring</code>提供了<code>JTA</code>介入方式，但是没有提供<code>JTA</code>实现，<code>JTA</code>的实现由容器来完成，例如<code>jboss</code>、<code>weblogic</code>、<code>websphere</code>等,我们常用的<code>tomcat</code>并没有进行实现，但我们可以借助其插件<code>jotm</code>或<code>atomikos</code>实现<code>JTA</code>。</p>
<h3 id="TCC模式（应用2PC）"><a href="#TCC模式（应用2PC）" class="headerlink" title="TCC模式（应用2PC）"></a>TCC模式（应用2PC）</h3><p><code>TCC</code>，全称<code>Try-Comfirm-Cancle</code>，它是基于应用层的<code>2PC</code>。一个完整的<code>TCC</code>有一个主业务服务和若干个从业务服务，<code>TCC</code>模式要求从业务服务提供三个接口：<code>Try</code>、<code>Confirm</code>和<code>Cancle</code>。</p>
<ul>
<li><code>Try</code>:完成所有的业务检查并预留必须的业务资源。</li>
<li><code>Confirm</code>:执行业务（不进行任何检查），且只使用<code>Try</code>阶段预留的业务资源，另外，<code>Confirm</code>操作需要满足幂等性(调用失败后，允许重新调用)。</li>
<li><code>Cancle</code>：释放<code>Try</code>阶段锁定的业务资源，<code>Cancle</code>操作需要满足幂等性(调用失败后，允许重新调用)。</li>
</ul>
<p><img src="tcc.png" alt="TCC模式"><br>TCC模式理论上可以很好的解决分布式数据一致性问题，但它也存以下几个问题：</p>
<ul>
<li>如果某个服务请求被阻塞，那么所有的服务请求将被阻塞，当然，我们可以通过超时设置来避免此问题；</li>
<li>如果事务管理器出现故障，那么所有的分布式请求将无法执行；</li>
<li>一次远程请求需要多次与事务管理器进行通信，请求中涉及的服务越多，通信次数越多，因此高并发的系统中，与事务管理器的通信会从很大程度上影响系统性能，因此高并发系统选用此模式时需慎重；</li>
</ul>
<h2 id="无状态服务机制"><a href="#无状态服务机制" class="headerlink" title="无状态服务机制"></a>无状态服务机制</h2><p>服务不进行持久化，即服务方法执行完后返回数据，最终是否持久化由最原始的调用者或统一构建的持久化服务决定和操作。</p>
<h2 id="如何选择解决方案"><a href="#如何选择解决方案" class="headerlink" title="如何选择解决方案"></a>如何选择解决方案</h2><ul>
<li>原则1：避免分布式事务</li>
<li>原则2：优先选择最终一致性方案，即可靠事件模式</li>
<li>原则3：最后选择两阶段提交法</li>
<li>原则4：如无必要，不要选择事务补偿机制</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java native方法]]></title>
      <url>/2017/11/21/java-native%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不要给自己找到不学习的理由</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JNI（Java Native Interface,Java本地接口）是一种编程框架,使得Java虚拟机中的Java程序可以调用本地应用/或库,也可以被其他程序调用。本地程序一般是用其它语言（C、C++或汇编语言等）编写的, 并且被编译为基于本机硬件和操作系统的程序。<br><a id="more"></a></p>
<p>我们知道，java标准库不支持的平台相关功能或者程序库，JNI允许程序员用其他编程语言来解决用纯粹的Java代码不好处理的情况，说白了java是高级的语言，纯粹的代码语言，不能直接和系统硬件对接，必须借助JNI来实现和平台系统的对接。许多基于JNI的标准库提供了很多功能给程序员使用, 例如文件I/O、音频相关的功能等。</p>
<blockquote>
<p>关于JNI的解释，百度google一大堆，笔者可自行去理解。本文只是说明<code>JVM</code>是如何调用<code>native方法</code>的。</p>
</blockquote>
<h1 id="陷阱与诱惑"><a href="#陷阱与诱惑" class="headerlink" title="陷阱与诱惑"></a><a href="https://zh.wikipedia.org/wiki/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">陷阱与诱惑</a></h1><ul>
<li>在使用JNI的过程中,可能因为某些微小的BUG,对整个JVM造成很难重现和调试的错误。</li>
<li>依赖于JNI的应用失去了Java的平台移植性（一种解决办法是为每个平台编写专门的JNI代码，然后在Java代码中,根据操作系统载入正确的JNI代码）。</li>
<li>JNI框架并没有对 non-JVM 内存提供自动垃圾回收机制, Native代码(如汇编语言)分配的内存和资源，需要其自身负责进行显式的释放。</li>
<li>JNI在某些情况下可能带来很大的开销和性能损失。<ul>
<li>调用 JNI 方法是很笨重的操作, 特别是在多次重复调用的情况下。</li>
<li>Native 方法不会被 JVM 内联, 也不会被 JIT compiled 优化 , 因为方法已经被编译过了。</li>
<li>Java 数组可能会被拷贝一份,以传递给 native 方法, 执行完之后再拷贝回去. 其开销与数组的长度是线性相关的.</li>
<li>如果传递一个对象给方法,或者需要一个回调,那么 Native 方法可能会自己调用JVM。 访问Java对象的属性、方法和类型时, Native代码需要类似reflection的东西。签名由字符串指定,通从JVM中查询。这非常缓慢并且容易出错。</li>
<li>Java 中的字符串(String) 也是对象, 有 length 属性,并且是编码过的. 读取或者创建字符串都需要一次时间复杂度为 O(n) 的复制操作.</li>
</ul>
</li>
</ul>
<h1 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h1><blockquote>
<p>参考<a href="http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html" target="_blank" rel="noopener">极客学院JNI开发流程</a></p>
</blockquote>
<p>开发 JNI 程序会受到系统环境的限制，因为用 <code>C/C++</code> 语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和 CPU 指令集，而且各个平台对标准 <code>C/C++</code> 的规范和标准库函数实现方式也有所区别。这就造成使用了 JNI 接口的 JAVA 程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。<br>JNI 开发流程主要分为以下 6 步： </p>
<ul>
<li>编写声明了 native 方法的 Java 类。</li>
<li>将 Java 源代码编译成 class 字节码文件</li>
<li>用 javah -jni 命令生成.h头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数）</li>
<li>用本地代码实现.h头文件中的函数</li>
<li>将本地代码编译成动态库（Windows：*.dll，linux/unix：*.so，mac os x：*.jnilib）</li>
<li>拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序  </li>
</ul>
<p><img src="开发流程.png" alt="开发流程"></p>
<h2 id="开发HelloWorld程序"><a href="#开发HelloWorld程序" class="headerlink" title="开发HelloWorld程序"></a>开发HelloWorld程序</h2><blockquote>
<p>以在linux环境下开发编译为例  </p>
</blockquote>
<h3 id="编写声明了-native-方法的-Java-类"><a href="#编写声明了-native-方法的-Java-类" class="headerlink" title="编写声明了 native 方法的 Java 类"></a>编写声明了 native 方法的 Java 类</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>; <span class="comment">// 1.声明这是一个native函数，由本地代码实现</span>

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        String text = sayHello(<span class="string">"hello jni"</span>);  <span class="comment">// 3.调用本地函数</span>
        System.out.println(<span class="string">"Hello,I'm java,the return String is : "</span> + text);
    }

    <span class="keyword">static</span> {
        System.loadLibrary(<span class="string">"HelloJNI"</span>);   <span class="comment">// 2.加载实现了native函数的动态库，只需要写动态库的名字</span>
    }
}
</code></pre>
<h3 id="编译class文件"><a href="#编译class文件" class="headerlink" title="编译class文件"></a>编译class文件</h3><pre><code class="java">$  /home/ccr/jdk1.7.0_80/bin/javac -cp /home/ccr/jdk1.7.0_80/jre/lib/rt.jar HelloJNI.java
</code></pre>
<h3 id="生成-h头文件"><a href="#生成-h头文件" class="headerlink" title="生成.h头文件"></a>生成.h头文件</h3><p><code>.h头文件</code>可以类比java接口类去理解。<code>.h</code>中一般放的是同名<code>.c</code>文件中定义的变量、数组、函数的声明，需要让<code>.c</code>外部使用的声明。头文件中只是申明变量函数，具体的初始化和实现放在同名<code>.c</code>文件或<code>.cpp</code>文件中。</p>
<pre><code class="java">$  /home/ccr/jdk1.7.0_80/bin/javah -jni -d ./jni HelloJNI
</code></pre>
<p>参数说明:</p>
<ul>
<li><code>classpath</code>：类搜索路径，这里表示从当前的 bin 目录下查找</li>
<li><code>d</code>：将生成的头文件放到当前的 jni 目录下</li>
<li><code>o</code>： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</li>
</ul>
<blockquote>
<p>注意：<code>-d</code>和<code>-o</code>只能使用其中一个参数。</p>
</blockquote>
<p>生成的头文件<code>jni/HelloJNI.h</code></p>
<pre><code class="c++">/- DO NOT EDIT THIS FILE - it is machine generated */
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span>
/- Header <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> */</span>
<span class="class"></span>
<span class="class">#<span class="title">ifndef</span> _<span class="title">Included_HelloJNI</span></span>
<span class="class">#<span class="title">define</span> _<span class="title">Included_HelloJNI</span></span>
<span class="class">#<span class="title">ifdef</span> __<span class="title">cplusplus</span></span>
<span class="class"><span class="title">extern</span> "<span class="title">C</span>" {</span>
<span class="meta">#<span class="meta-keyword">endif</span></span>
<span class="comment">/*</span>
<span class="comment"> - Class:     HelloJNI</span>
<span class="comment"> - Method:    sayHello</span>
<span class="comment"> - Signature: (Ljava/lang/String;)Ljava/lang/String;</span>
<span class="comment"> */</span>
JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello
  (JNIEnv *, jclass, jstring);

<span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span>
}
<span class="meta">#<span class="meta-keyword">endif</span></span>
<span class="meta">#<span class="meta-keyword">endif</span></span>
</code></pre>
<h3 id="实现头文件中申明的函数"><a href="#实现头文件中申明的函数" class="headerlink" title="实现头文件中申明的函数"></a>实现头文件中申明的函数</h3><p>编辑<code>HelloJNI.c</code></p>
<pre><code class="c"><span class="comment">// HelloJNI.c</span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloJNI.h&gt;</span></span>
/- Header <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> */</span>
<span class="class"></span>
<span class="class">#<span class="title">ifdef</span> __<span class="title">cplusplus</span>  </span>
<span class="class"><span class="title">extern</span> "<span class="title">C</span>"  </span>
<span class="class">{</span>  
<span class="meta">#<span class="meta-keyword">endif</span>  </span>
<span class="comment">/*</span>
<span class="comment"> - Class:     HelloJNI</span>
<span class="comment"> - Method:    sayHello</span>
<span class="comment"> - Signature: (Ljava/lang/String;)Ljava/lang/String;</span>
<span class="comment"> */</span>
JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello
  (JNIEnv *env, jclass cls, jstring j_str)
  {  
    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;  
    <span class="keyword">char</span> buff[<span class="number">128</span>] = { <span class="number">0</span> };  
    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);  
    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)  
    {  
        <span class="built_in">printf</span>(<span class="string">"out of memory.\n"</span>);  
        <span class="keyword">return</span> <span class="literal">NULL</span>;  
    }  
    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);  
    <span class="built_in">printf</span>(<span class="string">"Hello,I'm C++,the Java Str is:%s\n"</span>, c_str); 
    <span class="built_in">sprintf</span>(buff, <span class="string">"hello %s"</span>, c_str);  
    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);  
}  

<span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span>
}  
<span class="meta">#<span class="meta-keyword">endif</span></span>
</code></pre>
<h3 id="编译C文件"><a href="#编译C文件" class="headerlink" title="编译C文件"></a>编译C文件</h3><p>将 <code>C/C++</code> 代码编译成本地动态库文件动态库文件名命名规则：lib+动态库文件名+后缀（操作系统不一样，后缀名也不一样）如：</p>
<ul>
<li><code>Mac OS X</code> : <code>libHelloJNI.jnilib</code></li>
<li><code>Windows</code> ：<code>HelloJNI.dll</code>（不需要 <code>lib</code> 前缀）</li>
<li><code>Linux/Unix</code>：<code>libHelloJNI.so</code></li>
</ul>
<p>以在linux环境下编译为例</p>
<pre><code class="c">$  gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloJNI.c -o libHelloJNI.so
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>-I</code>： 包含编译JNI必要的头文件</li>
<li><code>-fPIC</code>： 编译成与位置无关的独立代码</li>
<li><code>-shared</code>：编译成动态库</li>
<li><code>-o</code>： 指定编译后动态库生成的路径和文件名</li>
</ul>
<p>用<code>-I</code>参数包含了 <code>JDK</code> 安装目录下的两个头文件目录，其中第一个目录为<code>jni.h头文件</code>所在目录，第二个是跨平台头文件目录（<code>Mac os x</code>系统下的目录名为 <code>darwin</code>，在 <code>Windows</code> 下目录名为 <code>win32</code>，<code>linux</code> 下目录名为 <code>linux</code>）,<br>用于定义与平台相关的宏，其中用于标识函数用途的两个宏 <code>JNIEXPORT</code> 和 <code>JNICALL</code>，就定义在 <code>linux</code> 目录下的<code>jni_md.h头文件</code>中。在 <code>Windows</code> 中编译 <code>dll</code> 动态库规定，如果动态库中的函数要被外部调用，需要在函数声明中添加<code>__declspec(dllexport)</code>标识，表示将该函数导出在外部可以调用。在 Linux/Unix 系统中，这两个宏可以省略不加。这两个平台的区别是由于各自的编译器所产生的可执行文件格式不一样。<br><code>JNICALL</code> 在 <code>Windows</code> 中的值为<code>__stdcall</code>，用于约束函数入栈顺序和堆栈清理的规则。<br>Windows 下<code>jni_md.h</code>头文件内容：</p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">ifndef</span> _JAVASOFT_JNI_MD_H_</span>
<span class="meta">#<span class="meta-keyword">define</span> _JAVASOFT_JNI_MD_H_</span>

<span class="meta">#<span class="meta-keyword">define</span> JNIEXPORT __declspec(dllexport)</span>
<span class="meta">#<span class="meta-keyword">define</span> JNIIMPORT __declspec(dllimport)</span>
<span class="meta">#<span class="meta-keyword">define</span> JNICALL __stdcall</span>

<span class="keyword">typedef</span> <span class="keyword">long</span> jint;
<span class="keyword">typedef</span> __int64 jlong;
<span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> jbyte;

<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !_JAVASOFT_JNI_MD_H_ */</span></span>
</code></pre>
<p>Linux 下<code>jni_md.h</code>头文件内容：</p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">ifndef</span> _JAVASOFT_JNI_MD_H_  </span>
<span class="meta">#<span class="meta-keyword">define</span> _JAVASOFT_JNI_MD_H_  </span>

<span class="meta">#<span class="meta-keyword">define</span> JNIEXPORT  </span>
<span class="meta">#<span class="meta-keyword">define</span> JNIIMPORT  </span>
<span class="meta">#<span class="meta-keyword">define</span> JNICALL  </span>

<span class="keyword">typedef</span> <span class="keyword">int</span> jint;  
<span class="meta">#<span class="meta-keyword">ifdef</span> _LP64 <span class="comment">/* 64-bit Solaris */</span>  </span>
<span class="keyword">typedef</span> <span class="keyword">long</span> jlong;  
<span class="meta">#<span class="meta-keyword">else</span>  </span>
<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> jlong;  
<span class="meta">#<span class="meta-keyword">endif</span>  </span>

<span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> jbyte;  

<span class="meta">#<span class="meta-keyword">endif</span></span>
</code></pre>
<p>从 <code>Linux</code> 下的<code>jni_md.h</code>头文件可以看出来，<code>JNIEXPORT</code> 和 <code>JNICALL</code> 是一个空定义，所以在 <code>Linux</code> 下 <code>JNI</code> 函数声明可以省略这两个宏。<br>用 javah 工具生成函数原型的头文件，函数命名规则为：<code>Java_类全路径_方法名</code>。如<code>Java_HelloJNI_sayHello</code>，其中<code>Java_</code>是函数的前缀，<code>HelloJNI</code>是类名(包含包路径用下划线如:<code>com_test_类名</code>)，<code>sayHello</code>是方法名，它们之间用 <code>_(下划线)</code> 连接。<br>再来看看函数的几个参数：</p>
<pre><code class="c++">JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello
  (JNIEnv *, jclass, jstring);
</code></pre>
<ul>
<li>第一个参数：JNIEnv* 是定义任意 native 函数的第一个参数（包括调用 JNI 的 RegisterNatives 函数注册的函数），指向 JVM 函数表的指针，函数表中的每一个入口指向一个 JNI 函数，每个函数用于访问 JVM 中特定的数据结构。</li>
<li>第二个参数：调用 Java 中 native 方法的实例或 Class 对象，如果这个 native 方法是实例方法，则该参数是 jobject，如果是静态方法，则是 jclass。</li>
<li>第三个参数：Java 对应 JNI 中的数据类型，Java 中 String 类型对应 JNI 的 jstring 类型。（详细介绍 JAVA 与 JNI 数据类型的映射关系参考<a href="http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/relational.html" target="_blank" rel="noopener">极客学院</a>）。</li>
</ul>
<p>函数返回值类型：夹在 JNIEXPORT 和 JNICALL 宏中间的 jstring，表示函数的返回值类型，对应 Java 的String 类型。</p>
<h3 id="运行-Java-程序"><a href="#运行-Java-程序" class="headerlink" title="运行 Java 程序"></a>运行 Java 程序</h3><pre><code class="c">$  /home/ccr/jdk1<span class="number">.7</span><span class="number">.0</span>_80/bin/java HelloJNI
</code></pre>
<p>Java 在调用 native (本地)方法之前，需要先加载动态库。如果在未加载动态之前就调用 native 方法，会抛出找不到动态链接库文件的异常。如下所示:</p>
<pre><code class="java">Exception in thread <span class="string">"main"</span> java.lang.UnsatisfiedLinkError: no HelloJNI in java.library.path
        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:<span class="number">1886</span>)
        at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">849</span>)
        at java.lang.System.loadLibrary(System.java:<span class="number">1088</span>)
        at HelloJNI.&lt;clinit&gt;(HelloJNI.java:<span class="number">11</span>)
</code></pre>
<p>一般在类的静态（static）代码块中加载动态库最合适，因为在创建类的实例时，类会被 <code>ClassLoader</code> 先加载到虚拟机，随后立马调用类的 <code>static</code> 静态代码块。这时再去调用 <code>native</code> 方法就万无一失了。加载动态库的两种方式：</p>
<pre><code class="java">System.loadLibrary(<span class="string">"HelloJNI"</span>);  
System.load(<span class="string">"/home/ccr/jvm/javatest/libHelloJNI.so"</span>);
</code></pre>
<ul>
<li>方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀</li>
<li>方式2：指定动态库的绝对路径名，需要加上前缀和后缀</li>
</ul>
<p>如果使用方式1，<code>java</code> 会去 <code>java.library.path</code> 系统属性指定的目录下查找动态库文件，如果没有找到会抛出<code>java.lang.UnsatisfiedLinkError</code> 异常。<br>只需要指定 <code>java.library.path</code> 即可</p>
<pre><code class="c">$  /home/ccr/jdk1<span class="number">.7</span><span class="number">.0</span>_80/bin/java -Djava.library.path=/home/ccr/jvm/javatest HelloJNI
</code></pre>
<h1 id="JVM-查找-native-方法"><a href="#JVM-查找-native-方法" class="headerlink" title="JVM 查找 native 方法"></a>JVM 查找 native 方法</h1><p>调用 <code>native</code> 方法之前，首先要调用 <code>System.loadLibrary</code> 接口加载一个实现了<code>native</code> 方法的动态库才能正常访问，否则就会抛出 <code>java.lang.UnsatisfiedLinkError</code> 异常，找不到 XX 方法的提示。现在我们想想，在 <code>Java</code> 中调用某个 <code>native</code> 方法时，<code>JVM</code> 是通过什么方式，能正确的找到动态库中 <code>C/C++</code> 实现的那个 <code>native</code> 函数呢？  </p>
<p><code>JVM</code> 查找<code>native</code> 方法有两种方式：</p>
<ul>
<li>按照 <code>JNI</code> 规范的命名规则</li>
<li><p>调用 <code>JNI</code> 提供的 <code>RegisterNatives</code> 函数，将本地函数注册到 <code>JVM</code>中。</p>
<h2 id="命名规则查找方式"><a href="#命名规则查找方式" class="headerlink" title="命名规则查找方式"></a>命名规则查找方式</h2><h3 id="加载本地库文件"><a href="#加载本地库文件" class="headerlink" title="加载本地库文件"></a>加载本地库文件</h3><h4 id="寻找本地库文件"><a href="#寻找本地库文件" class="headerlink" title="寻找本地库文件"></a>寻找本地库文件</h4><p>上一节中的示例使用的就是第一种方式,调用 <code>System.loadLibrary</code> 接口加载一个实现了<code>native</code> 方法的动态库。让我们来看看<code>System.loadLibrary</code>的具体实现。</p>
<pre><code class="java"><span class="meta">@CallerSensitive</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>{
  Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
}
</code></pre>
<p>其中<code>@CallerSensitive</code>这个注解是用来规避漏洞的，有兴趣的童鞋可以研究下，参考链接：<a href="http://blog.h5min.cn/aguda_king/article/details/72355807" target="_blank" rel="noopener">JDK8的@CallerSensitive</a>,<a href="http://m.blog.csdn.net/HEL_WOR/article/details/50199797" target="_blank" rel="noopener">JVM注解@CallSensitive</a>。<br><code>Reflection.getCallerClass()</code>方法返回调用者的类名，这里他返回是 <code>HelloJNI</code>。<br>然后调用 <code>java.lang.Runtime</code> 类中的 <code>loadLibrary0</code> 方法：</p>
<pre><code class="java"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">loadLibrary0</span><span class="params">(Class&lt;?&gt; fromClass, String libname)</span> </span>{
  SecurityManager security = System.getSecurityManager();
  <span class="keyword">if</span> (security != <span class="keyword">null</span>) {
      security.checkLink(libname);
  }
  <span class="keyword">if</span> (libname.indexOf((<span class="keyword">int</span>)File.separatorChar) != -<span class="number">1</span>) { <span class="comment">//使用该方法不允许使用绝对路径</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(
<span class="string">"Directory separator should not appear in library name: "</span> + libname);
  }
  ClassLoader.loadLibrary(fromClass, libname, <span class="keyword">false</span>);
}
</code></pre>
<p>该方法只是做了一些安全检查，从该方法中可以看出，使用 <code>System.loadLibrary</code> 方法不允许使用绝对路径。最终交给 <code>ClassLoader.loadLibrary</code> 去加载。<br><code>ClassLoader</code> 的 <code>loadLibrary</code> 方法：</p>
<pre><code class="java"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(Class&lt;?&gt; fromClass, String name, <span class="keyword">boolean</span> isAbsolute)</span> </span>{ 

      ...............

      <span class="comment">//false，System.load("/home/ccr/jvm/javatest/libHelloJNI.so") 该方式最终也进入到此方法，isAbsolute参数是true</span>
      <span class="keyword">if</span> (isAbsolute) {
          <span class="keyword">if</span> (loadLibrary0(fromClass, <span class="keyword">new</span> File(name))) {
              <span class="keyword">return</span>;
          }
          <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Can't load library: "</span> + name);
      }
      <span class="comment">//Class Loader找到的绝对路径（class path）下查找，但调试时返回是null，不知何解？</span>
      <span class="keyword">if</span> (loader != <span class="keyword">null</span>) {
          String libfilename = loader.findLibrary(name);
          ...............
      }
      <span class="comment">//尝试在sun.boot.library.path 定义的目录下查找</span>
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; sys_paths.length ; i++) {
          File libfile = <span class="keyword">new</span> File(sys_paths[i], System.mapLibraryName(name));
          <span class="keyword">if</span> (loadLibrary0(fromClass, libfile)) {
              <span class="keyword">return</span>;
          }
          <span class="comment">//备用位置，大部分平台都没实现，所以实现里面直接返回了null</span>
          libfile = ClassLoaderHelper.mapAlternativeName(libfile);
          <span class="keyword">if</span> (libfile != <span class="keyword">null</span> &amp;&amp; loadLibrary0(fromClass, libfile)) {
              <span class="keyword">return</span>;
          }
      }
      <span class="comment">//尝试在java.library.path 定义的目录下（windows下的PATH，linux下的LD_LIBRARY_PATH)</span>
      <span class="keyword">if</span> (loader != <span class="keyword">null</span>) {
          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; usr_paths.length ; i++) {
              File libfile = <span class="keyword">new</span> File(usr_paths[i],
                                      System.mapLibraryName(name));
              <span class="keyword">if</span> (loadLibrary0(fromClass, libfile)) {
                  <span class="keyword">return</span>;
              }
              ................
          }
      }
      <span class="comment">// Oops, it failed</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"no "</span> + name + <span class="string">" in java.library.path"</span>);
  }
</code></pre>
<p>其中可以看到，对于传入给 <code>System.loadLibrary(String libname)</code> 的参数 <code>libname</code> 是通过调用 <code>System.mapLibraryName</code> 方法来将其映射为库文件的文件名。<br>这个方法是一个<code>native</code>方法，不同系统有不同的实现，具体的区别主要在于前缀和扩展名的不同，例如在 <code>linux</code> 平台下前缀和扩展名分为定义为 <code>lib</code> 和 <code>.so</code> 。具体函数实现是在 <code>openjdk\jdk\src\share\native\java\lang\System.c</code>文件中。</p>
<pre><code class="c++">JNIEXPORT jstring JNICALL
Java_java_lang_System_mapLibraryName(JNIEnv *env, jclass ign, jstring libname)
{
  <span class="keyword">int</span> len;
  <span class="keyword">int</span> prefix_len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(JNI_LIB_PREFIX);
  <span class="keyword">int</span> suffix_len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(JNI_LIB_SUFFIX);

  jchar chars[<span class="number">256</span>];
  <span class="keyword">if</span> (libname == <span class="literal">NULL</span>) {
      JNU_ThrowNullPointerException(env, <span class="number">0</span>);
      <span class="keyword">return</span> <span class="literal">NULL</span>;
  }
  len = (*env)-&gt;GetStringLength(env, libname);
  <span class="keyword">if</span> (len &gt; <span class="number">240</span>) {
      JNU_ThrowIllegalArgumentException(env, <span class="string">"name too long"</span>);
      <span class="keyword">return</span> <span class="literal">NULL</span>;
  }
  cpchars(chars, JNI_LIB_PREFIX, prefix_len);
  (*env)-&gt;GetStringRegion(env, libname, <span class="number">0</span>, len, chars + prefix_len);
  len += prefix_len;
  cpchars(chars + len, JNI_LIB_SUFFIX, suffix_len);
  len += suffix_len;

  <span class="keyword">return</span> (*env)-&gt;NewString(env, chars, len);
}
</code></pre>
<p><code>JNI_LIB_PREFIX</code> 和 <code>JNI_LIB_PREFIX</code> 分别是前缀、后缀宏定义，针对<code>linux</code>系统该宏定义在 <code>openjdk\jdk\src\solaris\javavm\export\jvm_md.h</code> 文件中。</p>
<pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> JNI_LIB_PREFIX <span class="meta-string">"lib"</span></span>
<span class="meta">#<span class="meta-keyword">define</span> JNI_LIB_SUFFIX <span class="meta-string">".so"</span></span>
</code></pre>
<p>此次调试中，该方法返回 <code>libHelloJNI.so</code> 。找到库文件以后加载工作由 <code>ClassLoader.loadLibrary0</code> 方法完成。</p>
<h4 id="维护本地库列表"><a href="#维护本地库列表" class="headerlink" title="维护本地库列表"></a>维护本地库列表</h4><p>在讲加载本地库以前，先了解下 <code>NativeLibrary</code> 类，该类是 <code>ClassLoader</code> 的静态内部类。用于封装已经加载过的本地库信息。每个<code>NativeLibrary</code>对象都需要有一个<code>JNI</code>的版本号。这个版本号是虚拟机在载入本地库的时候获取并设置的。每个<code>ClassLoader</code>都会维护一个本地库表<code>private Vector&lt;NativeLibrary&gt; nativeLibraries</code>或者<code>private static Vector&lt;NativeLibrary&gt; systemNativeLibraries</code>（当<code>fromClass.getClassLoader()</code>返回<code>null</code>是即代表<code>BootStrapClassLoader</code>）,在加载本地库之前判断这个类库有没有在本地库列表中，有则直接返回。这样做防止了重复的去调用 <code>System.loadLibrary</code> 去加载同一个库。一个本地库只能被加载一次,这是因为<code>the JNI_OnLoad function can cause another loadLibrary invocation</code>。看代码：</p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadLibrary0</span><span class="params">(Class&lt;?&gt; fromClass, <span class="keyword">final</span> File file)</span> </span>{
      <span class="comment">// Check to see if we're attempting to access a static library</span>
      <span class="comment">//检查相应的类库是否被静态链接至vm</span>
      String name = NativeLibrary.findBuiltinLib(file.getName());
      <span class="keyword">boolean</span> isBuiltin = (name != <span class="keyword">null</span>);
      <span class="comment">//检查文件是否存在，以及获取文件标准路径</span>
      <span class="keyword">if</span> (!isBuiltin) {
          <span class="keyword">boolean</span> exists = AccessController.doPrivileged(
              <span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {
                  <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{
                      <span class="keyword">return</span> file.exists() ? Boolean.TRUE : <span class="keyword">null</span>;
                  }})
              != <span class="keyword">null</span>;
          <span class="keyword">if</span> (!exists) {
              <span class="keyword">return</span> <span class="keyword">false</span>;
          }
          <span class="keyword">try</span> {
              name = file.getCanonicalPath();
          } <span class="keyword">catch</span> (IOException e) {
              <span class="keyword">return</span> <span class="keyword">false</span>;
          }
      }
      <span class="comment">//去理解双亲委派模型，fromClass.getClassLoader()返回null时代表BootStrapClassLoader</span>
      ClassLoader loader =
          (fromClass == <span class="keyword">null</span>) ? <span class="keyword">null</span> : fromClass.getClassLoader();
      <span class="comment">//每个ClassLoader维护的本地库列表</span>
      Vector&lt;NativeLibrary&gt; libs =
          loader != <span class="keyword">null</span> ? loader.nativeLibraries : systemNativeLibraries;
      <span class="keyword">synchronized</span> (libs) {
          <span class="keyword">int</span> size = libs.size();
          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {
              NativeLibrary lib = libs.elementAt(i);
              <span class="comment">//已被当前ClassLoader加载则直接返回</span>
              <span class="keyword">if</span> (name.equals(lib.name)) {
                  <span class="keyword">return</span> <span class="keyword">true</span>;
              }
          }
          <span class="comment">//再看看有没有被其他ClassLoader加载</span>
          <span class="comment">//注意了，synchronized锁住的只是loadedLibraryNames对象</span>
          <span class="keyword">synchronized</span> (loadedLibraryNames) {
              <span class="comment">//加载了就抛异常</span>
              <span class="keyword">if</span> (loadedLibraryNames.contains(name)) {
                  <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError
                      (<span class="string">"Native Library "</span> +
                       name +
                       <span class="string">" already loaded in another classloader"</span>);
              }
              <span class="comment">//避免多次加载的原因</span>
              <span class="comment">/* If the library is being loaded (must be by the same thread,</span>
<span class="comment">               * because Runtime.load and Runtime.loadLibrary are</span>
<span class="comment">               * synchronous). The reason is can occur is that the JNI_OnLoad</span>
<span class="comment">               * function can cause another loadLibrary invocation.</span>
<span class="comment">               *</span>
<span class="comment">               * Thus we can use a static stack to hold the list of libraries</span>
<span class="comment">               * we are loading.</span>
<span class="comment">               *</span>
<span class="comment">               * If there is a pending load operation for the library, we</span>
<span class="comment">               * immediately return success; otherwise, we raise</span>
<span class="comment">               * UnsatisfiedLinkError.</span>
<span class="comment">               */</span>
              <span class="keyword">int</span> n = nativeLibraryContext.size();
              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
                  NativeLibrary lib = nativeLibraryContext.elementAt(i);
                  <span class="keyword">if</span> (name.equals(lib.name)) {
                      <span class="comment">//如果正在被加载的本地库是由同一个ClassLoader执行，则直接返回，否则异常</span>
                      <span class="keyword">if</span> (loader == lib.fromClass.getClassLoader()) {
                          <span class="keyword">return</span> <span class="keyword">true</span>;
                      } <span class="keyword">else</span> {
                          <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError
                              (<span class="string">"Native Library "</span> +
                               name +
                               <span class="string">" is being loaded in another classloader"</span>);
                      }
                  }
              }
              <span class="comment">//这个本地库从没有被加载过执行以下过程</span>
              <span class="comment">//nativeLibraryContext表示正在被其他线程加载的本地库</span>
              NativeLibrary lib = <span class="keyword">new</span> NativeLibrary(fromClass, name, isBuiltin);
              nativeLibraryContext.push(lib);
              <span class="keyword">try</span> {
                  <span class="comment">//加载的具体实现</span>
                  lib.load(name, isBuiltin);
              } <span class="keyword">finally</span> {
                  nativeLibraryContext.pop();
              }
              <span class="comment">//被正确加载后再维护本地库列表</span>
              <span class="keyword">if</span> (lib.loaded) {
                  loadedLibraryNames.addElement(name);
                  libs.addElement(lib);
                  <span class="keyword">return</span> <span class="keyword">true</span>;
              }
              <span class="keyword">return</span> <span class="keyword">false</span>;
          }
      }
  }
</code></pre>
<p>上面代码中<code>NativeLibrary.findBuiltinLib</code>方法可以去<a href="https://bugs.openjdk.java.net/browse/JDK-8081674" target="_blank" rel="noopener">这里</a>深入研究。<br>疑问：上面代码中每个<code>ClassLoader</code>都维护了自己的本地库列表，而本地库列表在所有的<code>ClassLoader</code>中只能出现一次，那为什么不直接存在一个静态列表中，像<code>loadedLibraryNames</code>一样？</p>
<h4 id="载入本地库"><a href="#载入本地库" class="headerlink" title="载入本地库"></a>载入本地库</h4><p>在<code>NativeLibrary</code>类中，有三个本地方法，<code>native void load(String name);</code>、<code>native void load(String name);</code>、<code>native void load(String name);</code>。分别是用来加载本地库，找到本地库的指针地址，卸载本地库。下面来看一下<code>load(String name)</code>方法的具体实现。源码在<code>openjdk\jdk\src\share\native\java\lang\ClassLoader.c</code>中。</p>
<pre><code class="c++">JNIEXPORT <span class="keyword">void</span> JNICALL
Java_java_lang_ClassLoader_00024NativeLibrary_load
(JNIEnv *env, jobject <span class="keyword">this</span>, jstring name, jboolean isBuiltin)
{
  <span class="keyword">const</span> <span class="keyword">char</span> *cname;
  jint jniVersion;
  jthrowable cause;
  <span class="keyword">void</span> * handle;

  <span class="keyword">if</span> (!initIDs(env))
      <span class="keyword">return</span>;

  cname = JNU_GetStringPlatformChars(env, name, <span class="number">0</span>);
  <span class="keyword">if</span> (cname == <span class="number">0</span>)
      <span class="keyword">return</span>;

  <span class="comment">//这个procHandle函数就是在findBuiltinLib方法中实现的，c++能力有限看不明白！</span>
  <span class="comment">//不管是procHandle或者JVM_LoadLibrary(cname)最终调用的是os::dll_load(name, ebuf, sizeof ebuf)</span>
  handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname);
  <span class="keyword">if</span> (handle) {
      JNI_OnLoad_t JNI_OnLoad;
      <span class="comment">//去查找.so文件中有没有实现JNI_OnLoad函数，这里我没有实现</span>
      JNI_OnLoad = (JNI_OnLoad_t)findJniFunction(env, handle,
                                             isBuiltin ? cname : <span class="literal">NULL</span>,
                                             JNI_TRUE);
      <span class="comment">//如果实现JNI_OnLoad，则必须返回JNI版本号，找不到直接用0x00010001</span>
      <span class="keyword">if</span> (JNI_OnLoad) {
          JavaVM *jvm;
          (*env)-&gt;GetJavaVM(env, &amp;jvm);
          jniVersion = (*JNI_OnLoad)(jvm, <span class="literal">NULL</span>);
      } <span class="keyword">else</span> {
          jniVersion = <span class="number">0x00010001</span>;
      }

      cause = (*env)-&gt;ExceptionOccurred(env);
      <span class="keyword">if</span> (cause) {
          (*env)-&gt;ExceptionClear(env);
          (*env)-&gt;Throw(env, cause);
          <span class="keyword">if</span> (!isBuiltin) {
              JVM_UnloadLibrary(handle);
          }
          <span class="keyword">goto</span> done;
      }

      <span class="keyword">if</span> (!JVM_IsSupportedJNIVersion(jniVersion) ||
          (isBuiltin &amp;&amp; jniVersion &lt; JNI_VERSION_1_8)) {
          <span class="keyword">char</span> msg[<span class="number">256</span>];
          jio_snprintf(msg, <span class="keyword">sizeof</span>(msg),
                       <span class="string">"unsupported JNI version 0x%08X required by %s"</span>,
                       jniVersion, cname);
          JNU_ThrowByName(env, <span class="string">"java/lang/UnsatisfiedLinkError"</span>, msg);
          <span class="keyword">if</span> (!isBuiltin) {
              JVM_UnloadLibrary(handle);
          }
          <span class="keyword">goto</span> done;
      }
      <span class="comment">//回调函数，将JNI版本号回填至NativeLibrary类中</span>
      (*env)-&gt;SetIntField(env, <span class="keyword">this</span>, jniVersionID, jniVersion);
  } <span class="keyword">else</span> {
      cause = (*env)-&gt;ExceptionOccurred(env);
      <span class="keyword">if</span> (cause) {
          (*env)-&gt;ExceptionClear(env);
          (*env)-&gt;SetLongField(env, <span class="keyword">this</span>, handleID, (jlong)<span class="number">0</span>);
          (*env)-&gt;Throw(env, cause);
      }
      <span class="keyword">goto</span> done;
  }
  <span class="comment">//回调函数，将handleID回填至NativeLibrary类中</span>
  (*env)-&gt;SetLongField(env, <span class="keyword">this</span>, handleID, ptr_to_jlong(handle));
  <span class="comment">//回调函数，将是否加载成功回填至NativeLibrary类中</span>
  (*env)-&gt;SetBooleanField(env, <span class="keyword">this</span>, loadedID, JNI_TRUE);

done:
  JNU_ReleaseStringPlatformChars(env, name, cname);
}
</code></pre>
<blockquote>
<p>注意：这里的 <code>_00024</code> 表示的是 <code>$</code> 符号，用来在java中表示内部类。</p>
</blockquote>
</li>
</ul>
<p>上面代码中加载的动作其实是 <code>procHandle</code> 或者 <code>JVM_LoadLibrary(cname)</code> ，二者最终都调用了<code>os::dll_load</code>函数。看 <code>JVM_LoadLibrary(cname)</code> 函数的实现，<code>D:\jvm\openjdk\hotspot\src\share\vm\prims\jvm.cpp</code></p>
<pre><code class="c++">JVM_ENTRY_NO_ENV(<span class="keyword">void</span>*, JVM_LoadLibrary(<span class="keyword">const</span> <span class="keyword">char</span>* name))
  <span class="comment">//%note jvm_ct</span>
  JVMWrapper2(<span class="string">"JVM_LoadLibrary (%s)"</span>, name);
  <span class="keyword">char</span> ebuf[<span class="number">1024</span>];
  <span class="keyword">void</span> *load_result;
  {
    <span class="function">ThreadToNativeFromVM <span class="title">ttnfvm</span><span class="params">(thread)</span></span>;
    <span class="comment">//调用os::dll_load函数</span>
    load_result = os::dll_load(name, ebuf, <span class="keyword">sizeof</span> ebuf);
  }
  <span class="keyword">if</span> (load_result == <span class="literal">NULL</span>) {
    <span class="keyword">char</span> msg[<span class="number">1024</span>];
    jio_snprintf(msg, <span class="keyword">sizeof</span> msg, <span class="string">"%s: %s"</span>, name, ebuf);
    <span class="comment">// Since 'ebuf' may contain a string encoded using</span>
    <span class="comment">// platform encoding scheme, we need to pass</span>
    <span class="comment">// Exceptions::unsafe_to_utf8 to the new_exception method</span>
    <span class="comment">// as the last argument. See bug 6367357.</span>
    Handle h_exception =
      Exceptions::new_exception(thread,
                                vmSymbols::java_lang_UnsatisfiedLinkError(),
                                msg, Exceptions::unsafe_to_utf8);

    THROW_HANDLE_0(h_exception);
  }
  <span class="keyword">return</span> load_result;
JVM_END
</code></pre>
<p>这个<code>os::dll_load</code> 函数是根据系统不同而由不同的实现的。<br>在 linux 系统下的实现在 <code>openjdk/hotspot/src/os/linux/vm/os_linux.cpp</code> 文件中,它其中主要做了两件事情，一个是使用 <code>linux</code> 的 <code>dlopen</code> 来打开这个<code>so</code>本地库文件，再则检查了这个so本地库文件是否和当前运行虚拟机的CPU架构是否相同。<code>dlopen</code>函数定义在 <code>dlfcn.h</code>，原型为：</p>
<pre><code class="c++"><span class="function"><span class="keyword">void</span> * <span class="title">dlopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> mode)</span></span>;
</code></pre>
<p>其中第二个参数使用的是 RTLD_LAZY: 异常绑定。<br>在<code>windows</code>的实现是使用 <code>LoadLibrary</code> 函数来加载 <code>dll</code> 本地库。​<br>本地库打开后，执行<code>JNI_OnLoad</code>函数获取JNI版本号，再将<code>handle</code>、<code>jniVersion</code>、<code>loaded</code>等回填至<code>NativeLibrary</code>类中。</p>
<h3 id="卸载本地库"><a href="#卸载本地库" class="headerlink" title="卸载本地库"></a>卸载本地库</h3><p>卸载和加载是相反的过程，卸载是在 <code>NativeLibrary</code> 类的 <code>finalize</code> 方法中调用的，而<code>finalize</code> 方法是在该类的示例被GC时调用。卸载的本地代码如下：</p>
<pre><code class="c++">JNIEXPORT <span class="keyword">void</span> JNICALL
Java_java_lang_ClassLoader_00024NativeLibrary_unload
(JNIEnv *env, jobject <span class="keyword">this</span>, jstring name, jboolean isBuiltin)
{
    <span class="keyword">const</span> <span class="keyword">char</span> *onUnloadSymbols[] = JNI_ONUNLOAD_SYMBOLS;
    <span class="keyword">void</span> *handle;
    JNI_OnUnload_t JNI_OnUnload;
     <span class="keyword">const</span> <span class="keyword">char</span> *cname;

    <span class="keyword">if</span> (!initIDs(env))
        <span class="keyword">return</span>;
    cname = JNU_GetStringPlatformChars(env, name, <span class="number">0</span>);
    <span class="keyword">if</span> (cname == <span class="literal">NULL</span>) {
        <span class="keyword">return</span>;
    }
    handle = jlong_to_ptr((*env)-&gt;GetLongField(env, <span class="keyword">this</span>, handleID));
    JNI_OnUnload = (JNI_OnUnload_t )findJniFunction(env, handle,
                                                isBuiltin ? cname : <span class="literal">NULL</span>,
                                                JNI_FALSE);
    <span class="keyword">if</span> (JNI_OnUnload) {
        JavaVM *jvm;
        (*env)-&gt;GetJavaVM(env, &amp;jvm);
        (*JNI_OnUnload)(jvm, <span class="literal">NULL</span>);
    }
    <span class="keyword">if</span> (!isBuiltin) {
        JVM_UnloadLibrary(handle);
    }
    JNU_ReleaseStringPlatformChars(env, name, cname);
}
</code></pre>
<p>先调用<code>JNI_OnUnload</code>函数，在调用<code>JVM_UnloadLibrary</code>进行卸载，最终调用<code>os::dll_unload(handle);</code>函数，该函数也是根据平台不同而实现。在<code>linux</code>平台上，使用 <code>dlopen</code> 函数来 <code>load</code> <code>so文件</code>， 使用 <code>dlclose</code> 函数来 <code>unload</code>。在<code>windows</code>平台上，使用 <code>LoadLibrary</code> 函数来<code>load</code> <code>dll文件</code>，来 <code>FreeLibrary</code> 函数来 <code>unload</code>。</p>
<h3 id="查找native方法"><a href="#查找native方法" class="headerlink" title="查找native方法"></a>查找native方法</h3><p>这里先来了解下方法的调用，方法在执行之前有一个解析和分派的过程（暂时只考虑静态解析过程），所有方法调用中的目标方法在<code>class文件</code>里都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分的符号引用转化为直接引用，就是方法的内存地址。（参考深入理解java虚拟机8.3章节）<br>JVM在加载类的时候发现某个方法有<code>ACC_NATIVE</code>标志，解析时会调用<code>ClassLoader</code>的<code>findNative</code>方法：</p>
<pre><code class="java"><span class="comment">// Invoked in the VM class linking code.</span>
<span class="comment">//name参数是native方法名对应C文件中的函数名,本次调试值为：Java_HelloJNI_sayHello</span>
<span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">findNative</span><span class="params">(ClassLoader loader, String name)</span> </span>{
    Vector&lt;NativeLibrary&gt; libs =
        loader != <span class="keyword">null</span> ? loader.nativeLibraries : systemNativeLibraries;
    <span class="keyword">synchronized</span> (libs) {
        <span class="keyword">int</span> size = libs.size();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {
            NativeLibrary lib = libs.elementAt(i);
            <span class="keyword">long</span> entry = lib.find(name);
            <span class="keyword">if</span> (entry != <span class="number">0</span>)
                <span class="keyword">return</span> entry;
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
<p>实际上就是查找本地库列表中有没有对应的方法。</p>
<pre><code class="c++">JNIEXPORT jlong JNICALL
Java_java_lang_ClassLoader_00024NativeLibrary_find
  (JNIEnv *env, jobject <span class="keyword">this</span>, jstring name)
{
    jlong handle;
    <span class="keyword">const</span> <span class="keyword">char</span> *cname;
    jlong res;

    <span class="keyword">if</span> (!initIDs(env))
        <span class="keyword">return</span> jlong_zero;
    <span class="comment">//存在NativeLibrary类中的handle</span>
    handle = (*env)-&gt;GetLongField(env, <span class="keyword">this</span>, handleID);
    cname = (*env)-&gt;GetStringUTFChars(env, name, <span class="number">0</span>);
    <span class="keyword">if</span> (cname == <span class="number">0</span>)
        <span class="keyword">return</span> jlong_zero;
    <span class="comment">//根据函数名去查找函数的入口地址，找不到就返回0</span>
    res = ptr_to_jlong(JVM_FindLibraryEntry(jlong_to_ptr(handle), cname));
    (*env)-&gt;ReleaseStringUTFChars(env, name, cname);
    <span class="keyword">return</span> res;
}
</code></pre>
<p><code>JVM_FindLibraryEntry</code>方法最终调用<code>os::dll_lookup</code>函数去查找入口地址。每个系统实现不一样，在<code>linux</code>平台上，使用<code>dlsym(handle, name)</code>函数来获取某个方法的内存地址。在<code>windows</code>平台上，使用 <code>GetProcAddress</code> 函数来获取某个方法的内存地址。​<br>这里面有一个比较重要的变量就是 <code>handleID</code> ，这个<code>handleID</code>是从哪里来，存在哪里都比较关键。首先我们来看这个<code>handleID</code>来至哪里，它其实是 <code>JVM_LoadLibrary</code> 返回的值，即 <code>dlopen</code> 返回的值，这个比较简单，它是在打开本地库时返回的句柄，然后这个句柄并没有保存在<code>native</code>层，而是将其保存在了<code>Java</code>层。</p>
<h2 id="RegisterNatives-函数"><a href="#RegisterNatives-函数" class="headerlink" title="RegisterNatives 函数"></a>RegisterNatives 函数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>回看上面的查找方法，依赖<code>JNI</code>的命名规则。加载类库时要按照一定的命名规则，最不可忍的是查找函数也要用到一定的方法名，这就导致java方法名不能修改。另外<code>jvm</code>调用本地函数时还要去寻找相应的入口，影响效率。如果想摆脱这种冗长的规则，就需要用到<code>RegisterNatives</code>函数来解决。<br><strong><code>RegisterNatives</code>函数是定义在<code>jni.h</code>头文件中的，遗憾的是我没有找到它的实现在哪，了解<code>RegisterNatives</code>之前先了解下<code>JNIEnv</code>，是定义在<code>jni.h</code>头文件中的一个机构体，里面就包含了<code>RegisterNatives</code>函数以及其他<code>JNI</code>的方法。<code>JNIEnv*</code> 是定义任意 <code>native</code> 函数的第一个参数,指向 JVM 函数表的指针，函数表中的每一个入口指向一个 <code>JNI</code> 函数，每个函数用于访问 <code>JVM</code> 中特定的数据结构(可以直接访问类实例以及方法区里面的数据)。<br>传统方式下，<code>Java</code>类<code>call</code>本地函数时，通常是依靠VM去动态寻找<code>.so</code>中的本地函数(因此它们才需要特定规则的命名格式)，而使用<code>RegisterNatives</code>将本地函数向<code>VM</code>进行登记，可以让其更有效率的找到函数,另外<code>RegisterNatives</code>函数还有一个优点，运行时动态调整本地函数与<code>Java</code>函数值之间的映射关系，只需要多次<code>call RegisterNatives()</code>方法，并传入不同的映射表参数即可。</strong><br><code>RegisterNatives</code>定义:</p>
<pre><code class="c++">jint (JNICALL *RegisterNatives)
      (JNIEnv *env, jclass clazz, <span class="keyword">const</span> JNINativeMethod *methods,
       jint nMethods);
</code></pre>
<p>重点关注<code>methods</code>参数，这就是上面说的本地函数与<code>Java</code>函数值之间的映射表，映射表的数据结构如下：</p>
<pre><code class="c++"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span>
    <span class="keyword">char</span> *name;    <span class="comment">//java 中的方法名</span>
    <span class="keyword">char</span> *signature; <span class="comment">//方法签名 </span>
    <span class="keyword">void</span> *fnPtr; <span class="comment">//native函数指针</span>
} JNINativeMethod;
<span class="comment">//以下是java.lang.Object类中本地方法映射表</span>
<span class="keyword">static</span> JNINativeMethod methods[] = {
    {<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode},
    {<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait},
    {<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify},
    {<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll},
    {<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone},
};
<span class="comment">//下面是一般情况下的定义，getNativeString是java方法名</span>
<span class="comment">//getString是本地函数名,reinterpret_cast&lt;void*&gt;强制转换成了函数指针</span>
<span class="keyword">static</span> JNINativeMethod methods[] = {
        {<span class="string">"getNativeString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(getString)}
};
</code></pre>
<p>第三个参数<code>*fnPtr</code>估计就是<code>java</code>方法调用所需要的这是引用，<code>java</code>在进行本地方法调用时不需要去搜索本地方法的引用，很大程度上提升了效率。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用<code>RegisterNatives</code> 函数进行本地函数登记的方法一般有两种，第一种是在class中多加一个本地方法用来调用 <code>RegisterNatives</code> 函数，第二种是利用<code>JNI_OnLoad()</code>方法。<br>第一种方式是jdk中使用的方法，我们来看一段JDK源码,<code>java.lang.Object</code>:</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>{
    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;
    <span class="keyword">static</span> {
        registerNatives();
    }
    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();
    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;
}
</code></pre>
<p><code>java.lang.Object</code>类中定义了6个本地方法，并且在<code>static</code>块中调用了第一个本地方法。来看看本地方法的实现：<code>D:\jvm\openjdk\jdk\src\share\native\java\lang\Object.c</code>:</p>
<pre><code class="c++">
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span>

<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni_util.h"</span></span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jvm.h"</span></span>

<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"java_lang_Object.h"</span></span>

<span class="keyword">static</span> JNINativeMethod methods[] = {
    {<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode},
    {<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait},
    {<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify},
    {<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll},
    {<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone},
};

JNIEXPORT <span class="keyword">void</span> JNICALL
Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)
{
    (*env)-&gt;RegisterNatives(env, cls,
                            methods, <span class="keyword">sizeof</span>(methods)/<span class="keyword">sizeof</span>(methods[<span class="number">0</span>]));
}

JNIEXPORT jclass JNICALL
Java_java_lang_Object_getClass(JNIEnv *env, jobject <span class="keyword">this</span>)
{
    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) {
        JNU_ThrowNullPointerException(env, <span class="literal">NULL</span>);
        <span class="keyword">return</span> <span class="number">0</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> (*env)-&gt;GetObjectClass(env, <span class="keyword">this</span>);
    }
}
</code></pre>
<p>一目了然，<code>registerNatives</code>方法利用传统方式调用，其他的方法在<code>registerNatives</code>方法里面进行注册即可。<br>利用<code>JNI_OnLoad()</code>方法进行注册也很简单，回想一下<code>ClassLoader</code>在装载库文件之后会调用库文件中的<code>JNI_OnLoad()</code>方法，只要在库文件中实现<code>JNI_OnLoad()</code>方法即可。</p>
<pre><code class="c++">JNIEXPORT <span class="keyword">void</span> JNICALL
Java_java_lang_ClassLoader_00024NativeLibrary_load
  (JNIEnv *env, jobject <span class="keyword">this</span>, jstring name, jboolean isBuiltin)
{

    JNI_OnLoad_t JNI_OnLoad;
    <span class="comment">//去查找.so文件中有没有实现JNI_OnLoad函数，这里我没有实现</span>
    JNI_OnLoad = (JNI_OnLoad_t)findJniFunction(env, handle,
                                           isBuiltin ? cname : <span class="literal">NULL</span>,
                                           JNI_TRUE);
    <span class="comment">//如果实现JNI_OnLoad，则必须返回JNI版本号，找不到直接用0x00010001</span>
    <span class="keyword">if</span> (JNI_OnLoad) {
        JavaVM *jvm;
        (*env)-&gt;GetJavaVM(env, &amp;jvm);
        jniVersion = (*JNI_OnLoad)(jvm, <span class="literal">NULL</span>);
    } <span class="keyword">else</span> {
        jniVersion = <span class="number">0x00010001</span>;
    }
}
</code></pre>
<p><code>findJniFunction</code>实际上调用的是<code>JVM_FindLibraryEntry(handle, jniFunctionName)</code>方法，跟<code>Java_java_lang_ClassLoader_00024NativeLibrary_find</code>类似。<br>疑问：调试时<code>jniFunctionName</code>参数是<code>JNI_OnLoad_HelloJNI</code>并非是<code>JNI_OnLoad</code>，所以<code>libHello.so</code>到底实现<code>JNI_OnLoad_HelloJNI</code>还是是<code>JNI_OnLoad</code>？我并没有去试。<br><code>libHello.so</code>的实现可以是下面的样子（未测试）。</p>
<pre><code class="c++"><span class="comment">// HelloJNI.c</span>
<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloJNI.h&gt;</span></span>
/- Header <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> */</span>
<span class="class"></span>
<span class="class">#<span class="title">ifdef</span> __<span class="title">cplusplus</span>  </span>
<span class="class"><span class="title">extern</span> "<span class="title">C</span>"  </span>
<span class="class">{</span>  
<span class="meta">#<span class="meta-keyword">endif</span>  </span>
<span class="comment">/*</span>
<span class="comment"> - Class:     HelloJNI</span>
<span class="comment"> - Method:    sayHello</span>
<span class="comment"> - Signature: (Ljava/lang/String;)Ljava/lang/String;</span>
<span class="comment"> */</span>
 <span class="comment">//这里的方法名可以随便取咯</span>
JNIEXPORT jstring JNICALL sayHi
  (JNIEnv *env, jclass cls, jstring j_str)
  {  
    <span class="keyword">const</span> <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;  
    <span class="keyword">char</span> buff[<span class="number">128</span>] = { <span class="number">0</span> };  
    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);  
    <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>)  
    {  
        <span class="built_in">printf</span>(<span class="string">"out of memory.\n"</span>);  
        <span class="keyword">return</span> <span class="literal">NULL</span>;  
    }  
    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);  
    <span class="built_in">printf</span>(<span class="string">"Hello,I'm C++,the Java Str is:%s\n"</span>, c_str); 
    <span class="built_in">sprintf</span>(buff, <span class="string">"hello %s"</span>, c_str);  
    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, buff);  
}  

<span class="comment">//定义映射表</span>
<span class="keyword">static</span> JNINativeMethod methods[] = {
        {<span class="string">"sayHello"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(sayHi)}
};

<span class="comment">//有可能是JNI_OnLoad_HelloJNI</span>
<span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span></span>
<span class="function"></span>{
    <span class="comment">//这段代码网上copy的，并没有实测，不过该函数必须返回JNI版本号，默认版本号上面也有</span>
    JNIEnv* env;
    <span class="keyword">if</span> (JNI_OK != vm-&gt;GetEnv(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt; (&amp;env),JNI_VERSION_1_4)) {
        <span class="keyword">return</span> JNI_ERR;
    }

    g_jvm = vm; <span class="comment">//用于后面获取JNIEnv</span>
    jclass clazz = env-&gt;FindClass(<span class="string">"com/example/myndkproj/NativeLib"</span>);  <span class="comment">//获取Java NativeLib类</span>

    <span class="comment">//注册Native方法</span>
    <span class="keyword">if</span> (env-&gt;RegisterNatives(clazz, methods, <span class="keyword">sizeof</span>(methods)/<span class="keyword">sizeof</span>((methods)[<span class="number">0</span>])) &lt; <span class="number">0</span>) {
        LOGW(<span class="string">"RegisterNatives error"</span>);
        <span class="keyword">return</span> JNI_ERR;
    }

    <span class="keyword">return</span> JNI_VERSION_1_4;
}

<span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span>
}  
<span class="meta">#<span class="meta-keyword">endif</span></span>
</code></pre>
<blockquote>
<p>参考：<a href="http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html" target="_blank" rel="noopener">极客学院</a>   <a href="http://blog.crasheye.cn/jvm-local-lib-loading-code-reading.html" target="_blank" rel="noopener">Crasheye’s Blog</a>  <a href="http://jellypaul.github.io/java/2016/11/15/JNI-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%9A%E8%BF%87RegisterNatives%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">JellyJoe</a> <a href="http://techbook.blog.163.com/blog/static/304885102012235613945/" target="_blank" rel="noopener">奔IV的博客</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> java源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jni </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[了解java标准类库]]></title>
      <url>/2017/11/15/%E4%BA%86%E8%A7%A3java%E6%A0%87%E5%87%86%E7%B1%BB%E5%BA%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>参考jdk8标准</p>
</blockquote>
<p>在阅读<code>java</code>源码之前，首先要了解<code>java</code>各个类库有什么样的作用，各个类库之前又有什么样的关联。</p>
<h1 id="java-applet包"><a href="#java-applet包" class="headerlink" title="java.applet包"></a>java.applet包</h1><p>包括<code>Applet</code>类和几个接口，用于创建<code>Java</code>小程序，处理小程序与浏览器之间的相互作用，包括声音图像等多媒体的处理。扩展包<code>javax.swing</code>增加了<code>JApplet</code>，该类派生自<code>Applet</code>，是其扩展版。<code>applet</code>现在主流浏览器几乎不用，可以忽略。<br> <a id="more"></a></p>
<h1 id="java-awt包"><a href="#java-awt包" class="headerlink" title="java.awt包"></a>java.awt包</h1><p>该包包括许多Java早期的图形界面设计相关的类与接口，包括定义字体、颜色、集合绘图和图像显示等。</p>
<h1 id="java-beans-包"><a href="#java-beans-包" class="headerlink" title="java.beans 包"></a>java.beans 包</h1><p>包含与开发 <code>beans</code> 有关的类，即基于 <code>JavaBeans</code> 架构的组件。 <code>java</code>反射就用到了此包。</p>
<h1 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h1><p>该包包括处理字节数据流(<code>InputStream</code>, <code>OutputStream</code>)，字符数据流(<code>Reader</code>, <code>Writer</code>)，文件操作类(<code>File</code>)等，实现各种不同的输入输出功能。</p>
<h1 id="java-lang包"><a href="#java-lang包" class="headerlink" title="java.lang包"></a>java.lang包</h1><p>是提供利用 <code>Java</code> 编程语言进行程序设计的基础类。编程用到该包中的类时，无需使用<code>import</code>语句引入他们，由编译器自动引入。<br>该类包含最重要的类<code>Object</code>、数据类型的包装类 (<code>Boolean</code>,<code>Character</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code>, <code>Long</code> 等)、数学类 (<code>Math</code>)、系统类(<code>System</code>)和运行时类(<code>Runtime</code>)、字符串类 <code>String</code>, <code>StringBuffer</code>)、异常处理类(<code>Throwable</code>, <code>Exception</code>,<code>Error</code>)、线程类 (<code>Thread</code>, <code>Runnable</code>接口)、类操作类(<code>Class</code>)、<code>annotation</code>包等。</p>
<h1 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h1><p>用来处理任意精度的整形或浮点型数据的。<code>BigDecimal</code>和<code>BigInteger</code>等。</p>
<h1 id="java-net包"><a href="#java-net包" class="headerlink" title="java.net包"></a>java.net包</h1><p>用于网络通信，实现网络功能。</p>
<h1 id="java-nio包"><a href="#java-nio包" class="headerlink" title="java.nio包"></a>java.nio包</h1><p><code>Java NIO</code>是<code>java 1.4</code>之后新出的一套<code>IO</code>接口，这里的的新是相对于原有标准的<code>Java IO</code>和<code>Java Networking</code>接口。<code>NIO</code>提供了一种完全不同的操作方式。</p>
<ul>
<li><code>Java NIO: Channels and Buffers</code><br>标准的<code>IO</code>编程接口是面向字节流和字符流的。而<code>NIO</code>是面向通道和缓冲区的，数据总是从通道中读到<code>buffer</code>缓冲区内，或者从<code>buffer</code>写入到通道中。</li>
<li><code>Java NIO: Non-blocking IO</code><br><code>Java NIO</code>使我们可以进行非阻塞<code>IO</code>操作。比如说，单线程中从通道读取数据到<code>buffer</code>，同时可以继续做别的事情，当数据读取到<code>buffer</code>中后，线程再继续处理数据。写数据也是一样的。</li>
<li><code>Java NIO: Selectors</code><br><code>NIO</code>中有一个“<code>slectors</code>”的概念。<code>selector</code>可以检测多个通道的事件状态（例如：链接打开，数据到达）这样单线程就可以操作多个通道的数据。</li>
</ul>
<h1 id="java-rmi包"><a href="#java-rmi包" class="headerlink" title="java.rmi包"></a>java.rmi包</h1><p>提供远程方法调用接口。</p>
<h1 id="java-security包"><a href="#java-security包" class="headerlink" title="java.security包"></a>java.security包</h1><p>为安全框架提供类和接口。</p>
<h1 id="java-sql包"><a href="#java-sql包" class="headerlink" title="java.sql包"></a>java.sql包</h1><p>用于数据库操作的一些类。</p>
<h1 id="java-text包"><a href="#java-text包" class="headerlink" title="java.text包"></a>java.text包</h1><p>提供以与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。典型的<code>DateFormat</code>就在该包内。</p>
<h1 id="java-time包"><a href="#java-time包" class="headerlink" title="java.time包"></a>java.time包</h1><p>时间处理包。</p>
<h1 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h1><p>Java提供一些常用的实用功能类，数据结构的<code>Java</code>实现类。日期时间类（<code>Date</code>，<code>Calender</code>）、随机数类（<code>Random</code>）、向量类（<code>Vector</code>）、堆栈类（<code>Stack</code>）、散列表类（<code>Hashtable</code>）、<code>Java</code>集合框架。</p>
<h1 id="javax包"><a href="#javax包" class="headerlink" title="javax包"></a>javax包</h1><p><code>javax</code>是<code>java</code>的扩展包,如<code>j2ee</code> 中的类库，包括<code>servlet</code>，<code>jsp</code>，<code>ejb</code>，数据库相关的一些东西，<code>xml</code>等。</p>
]]></content>
      
        <categories>
            
            <category> java源码阅读 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[win10利用Netbeans远程构建调试OpenJDK]]></title>
      <url>/2017/11/10/win10%E5%88%A9%E7%94%A8Netbeans%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA%E8%B0%83%E8%AF%95OpenJDK/</url>
      <content type="html"><![CDATA[<h1 id="NetBeans远程开发"><a href="#NetBeans远程开发" class="headerlink" title="NetBeans远程开发"></a>NetBeans远程开发</h1><p>在开发<code>linux</code>下的<code>C/C++</code>程序的时候，不可避免的会遇到在<code>windows</code>下进行开发，而在<code>linux</code>上编译和调试的场景。常见的解决方式是在<code>windows</code>上安装一个<code>linux</code>虚拟机，然后在<code>Linux</code>上编写代码，编译和调试。如果虚拟机不装图形界面会导致开发效率低，而如果安装了图形界面又会大量的占用系统资源。安装无界面的<code>linux</code>虚拟机，同时使用<code>NetBeans</code>的远程开发功能在<code>windows</code>下进行开发，可以很好的解决这个问题。<br>需要了解<code>NetBeans</code>远程开发请参考：<a href="https://netbeans.org/kb/docs/cnd/remotedev-tutorial_zh_CN.html" target="_blank" rel="noopener">https://netbeans.org/kb/docs/cnd/remotedev-tutorial_zh_CN.html</a><br>众所周知，在<code>windows</code>上编译及调试<code>openJDK</code>极为复杂，会遇到各种各样的问题，而且网络上的教程很少且大部分是以前的版本。而在<code>Linux</code>上编译调试<code>OpenJDK</code>相对简单的多。利用这一点，读者可在<code>windows</code>上安装<code>NetBeans</code>，利用其远程开发的功能，实现在<code>windows</code>上使用<code>Linux</code>环境对<code>OpenJdk</code>进行调试。<br> <a id="more"></a></p>
<h1 id="准备Linux环境编译openJDK"><a href="#准备Linux环境编译openJDK" class="headerlink" title="准备Linux环境编译openJDK"></a>准备<code>Linux</code>环境编译<code>openJDK</code></h1><p>既然是使用<code>Linux</code>环境，那<code>Linux</code>环境自然需要配置成能对<code>OpenJdk</code>进行编译。<code>Linux</code>环境编译<code>OpenJDK</code>网上已经有很多教程，在此只是简单的说下步骤</p>
<h2 id="准备Linux环境。"><a href="#准备Linux环境。" class="headerlink" title="准备Linux环境。"></a>准备<code>Linux</code>环境。</h2><p>我选择<code>Ubuntu17</code>版本在<code>VirtualBox</code>上安装，<code>make</code>版本原本是<code>4.1</code>版本，<code>gcc</code>和<code>g++</code>版本是<code>6.3.0</code>，但在编译过程中出现一些问题，后来将版本降至<code>4.7</code>，为了能实现远程调试，环境必须有<code>GDB</code>。<code>bootjdk</code> jdk7版本。</p>
<pre><code class="c">$ make -v 
GNU Make <span class="number">4.1</span>
$ gcc -v
gcc version <span class="number">4.7</span><span class="number">.4</span>
$ g++ -v
gcc version <span class="number">4.7</span><span class="number">.4</span>
$ gdb -v
GNU gdb <span class="number">7.12</span><span class="number">.50</span><span class="number">.20170314</span>-git
</code></pre>
<h2 id="获取OpenJDK源码。"><a href="#获取OpenJDK源码。" class="headerlink" title="获取OpenJDK源码。"></a>获取OpenJDK源码。</h2><p>这里我选择<code>openjdk-8-src-b132-03_mar_2014.zip</code></p>
<h2 id="配置config（预构建）"><a href="#配置config（预构建）" class="headerlink" title="配置config（预构建）"></a>配置<code>config</code>（预构建）</h2><pre><code class="c">bash ./configure  --with-debug-level=slowdebug --with-target-bits=<span class="number">64</span> --with-boot-jdk=/home/ccr/jdk1<span class="number">.7</span><span class="number">.0</span>_80
</code></pre>
<p>在配置的过程中，会提示环境缺少的各种包，按照提示一次安装即可，在提示安装 <code>libX11-dev</code>依赖时，<code>ubuntu</code>怎么也安装不上，后来发现<code>x</code>大写了，改成小写就行了，配置完成后如下图：<br><img src="3433091-cf63f9d61aff491c.png" alt="配置完成"></p>
<h2 id="make-all-构建"><a href="#make-all-构建" class="headerlink" title="make all(构建)"></a><code>make all</code>(构建)</h2><p>在构建时有可能遇到以下问题，解决方法也在下面：</p>
<ul>
<li><h3 id="This-OS-is-not-supported"><a href="#This-OS-is-not-supported" class="headerlink" title="This OS is not supported:"></a><code>This OS is not supported</code>:</h3>在<code>/openjdk/hotspot/make/linux/Makefile</code>文件的228行，写明了该版本<code>openJDK</code>所支持的<code>OS</code>版本，通过<code>uname -r</code>命令查出系统的版本，添加到228行后面重新编译即可（<code>make clean</code>）。<br><img src="3433091-949599abc82796ee.png" alt="uname-r"></li>
<li><h3 id="invalid-option-39-39"><a href="#invalid-option-39-39" class="headerlink" title="invalid option -- &#39;/&#39;"></a><code>invalid option -- &#39;/&#39;</code></h3><img src="3433091-34c85d83d29b3642.png" alt="clipboard.png"><br>解决办法：删除66-67行之间的那段<pre><code class="c">$ vim hotspot/make/linux/makefiles/adjust-mflags.sh
<span class="number">63</span> MFLAGS=`
<span class="number">64</span>         echo <span class="string">"$MFLAGS"</span> \
<span class="number">65</span>         | sed '
<span class="number">66</span>                 s/^-/ -/
                   s/ -\([^        ][^     ]*\)j/ -\<span class="number">1</span> -j/
<span class="number">67</span>                 s/ -j[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]*/ -j/
<span class="number">68</span>                 s/ -j\([^       ]\)/ -j -\<span class="number">1</span>/
<span class="number">69</span>                 s/ -j/ -j'${HOTSPOT_BUILD_JOBS:-${default_build_jobs}}<span class="string">'/</span>
70         ' `
</code></pre>
</li>
<li><h3 id="invalid-suffix-on-literal"><a href="#invalid-suffix-on-literal" class="headerlink" title="invalid suffix on literal"></a><code>invalid suffix on literal</code></h3><img src="3433091-49695fd38841bd8c.png" alt="clipboard.png"><br><img src="3433091-f66ab57efafab79e.png" alt="clipboard.png"><br>这是因为<code>gcc</code>和<code>g++</code>版本过高导致，降低<code>gcc</code>版本至<code>4.7</code>.<pre><code class="c"><span class="comment">//1 安装</span>
$ sudo apt-get install -y gcc<span class="number">-4.7</span>
$ sudo apt-get install -y g++<span class="number">-4.7</span>
<span class="comment">//2 重新建立软连接</span>
$ cd /usr/bin
$ sudo rm -r gcc
$ sudo ln -sf gcc<span class="number">-4.7</span> gcc
$ sudo rm -r g++
$ sudo ln -sf g++<span class="number">-4.7</span> g++
</code></pre>
</li>
<li><h3 id="Werror-deprecated-declarations"><a href="#Werror-deprecated-declarations" class="headerlink" title="-Werror=deprecated-declarations"></a><code>-Werror=deprecated-declarations</code></h3><img src="3433091-a2b772bd714d673f.png" alt="clipboard.png"><br>解决办法<pre><code class="c">$ vim hotspot/make/linux/makefiles/gcc.make
# Compiler warnings are treated as errors
# WARNINGS_ARE_ERRORS = -Werror #注释这一行
</code></pre>
构建完成后出现如下图所示内容，说明构建成功<br><img src="3433091-0df8893f2ea2b223.png" alt="clipboard.png"><h1 id="windows-NetBeans构建调试"><a href="#windows-NetBeans构建调试" class="headerlink" title="windows NetBeans构建调试"></a><code>windows</code> <code>NetBeans</code>构建调试</h1>远程调试一般有两种方式，一种是将本地源码通过<code>sftp</code>的方式复制到目标机器，目标机器进行编译后的结果在复制到本地，这种方式针对小型项目效果还是不错的，但是对<code>OpenJDK</code>这种大型项目，复制无疑是非常耗时的，有时还会出现异常。另一种方式是将<code>windows</code>的文件夹共享至网络中，<code>linux</code>通过<code>mount</code>命令将网络中的文件夹挂在至<code>Linux</code>系统，并且赋予读写和执行权限，这样<code>windows</code>和<code>Linux</code>就能共同操作统一文件夹。毫无疑问本教程使用第二种方式。<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2>在D盘新建<code>jvm</code>文件夹（作为共享文件夹），将<code>OpenJDK</code>解压至该文件夹。安装<code>NetBeans</code>（我选择最新版本8.2）。<h2 id="分享文件夹"><a href="#分享文件夹" class="headerlink" title="分享文件夹"></a>分享文件夹</h2>分享<code>jvm</code>文件夹。在<code>windows</code>上操作如下，选择一个账户进行共享，共享结束后，右键-&gt;属性，查看共享状态。<br><img src="3433091-b5b4b9bbc0ef5f7e.png" alt="clipboard.png"><br><img src="3433091-79cfd9a78d692fe5.png" alt="clipboard.png"><br><img src="3433091-4e0b8dd48584c661.png" alt="clipboard.png"><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2>在<code>Linux</code>上使用<code>mount</code>命令挂载<pre><code class="c">$ id ccr
uid=<span class="number">1000</span>(ccr) gid=<span class="number">1000</span>(ccr) groups=<span class="number">1000</span>(ccr)
$ sudo mount <span class="comment">//192.168.2.176/jvm /home/ccr/jvm/ -o username=ccr,password=ccr,gid=1000,uid=1000</span>
</code></pre>
参数依次是资源文件夹的<code>IP</code>和文件夹，挂载到目标机器的目录（必须先创建），<code>username</code>文件夹共享的<code>windows</code>账户，<code>password</code>密码，<code>gid</code>和<code>uid</code>是控制挂载后控制该目录的所有者，可以通过<code>id username</code>来获取。挂载成功后使用<code>ll</code>命令到<code>jvm</code>文件夹查看结果。<br><img src="http://upload-images.jianshu.io/upload_images/3433091-c0d5b0f94e934ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="clipboard.png"><h2 id="NetBeans构建主机。"><a href="#NetBeans构建主机。" class="headerlink" title="NetBeans构建主机。"></a><code>NetBeans</code>构建主机。</h2>打开<code>NetBeans</code>，窗口-&gt;服务-&gt;右键  <code>c\c++</code>构建主机  添加主机。填写目标机器的IP及操作用户（<code>Linux</code>上必须安装<code>ssh</code>），我这里使用<code>ccr</code>用户。 最后项目文件的访问方式一定要选择【系统级别文件共享（<code>NFS</code>,<code>Samba</code>等）】，添加主机后 位主机设置路径映射。<br><img src="3433091-e4c0fa4fcda389b6.png" alt="clipboard.png"><br><img src="3433091-26cea2b1b64425d5.png" alt="clipboard.png"><br><img src="3433091-c6a24ce48352da6a.png" alt="clipboard.png"><br><img src="3433091-01f33f5c624cb110.png" alt="QQ截图20171110151648.png"><br><img src="3433091-214d6e2b941518d0.png" alt="QQ截图20171110151807.png"><h2 id="NetBeans构建项目。"><a href="#NetBeans构建项目。" class="headerlink" title="NetBeans构建项目。"></a><code>NetBeans</code>构建项目。</h2></li>
<li>文件-&gt;新建项目，选择，<code>c/c++</code>，基于现有源代码的<code>c/c++</code>项目<br><img src="3433091-f64aac29218fb0d5.png" alt="clipboard.png"></li>
<li>选择<code>openJdk</code>目录，选择构建的主机，选择定制<br><img src="3433091-6fdd756df1f4f842.png" alt="clipboard.png"></li>
<li>写上预定以参数，这个参数和之前编译时的参数一直就行了<pre><code class="c">./configure  --with-debug-level=slowdebug --with-target-bits=<span class="number">64</span> --with-boot-jdk=/home/ccr/jdk1<span class="number">.7</span><span class="number">.0</span>_80
</code></pre>
<img src="3433091-b161f3c3a41bca4a.png" alt="clipboard.png"></li>
<li>一直点下一步，直到最后一步，项目名称改成<code>openjdk8u</code><br><img src="3433091-ac9205fd316af1ed.png" alt="clipboard.png"></li>
<li>点击完成后，项目开始配置和构建，在构建过程中遇到的问题，可以参考上面的编译过程去解决，然后重新清理和构建，直到构建成功为止。构建大概30分钟。<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2>构建过程中出现错误。<code>failed to create symbolic link： Operation not supported</code><br>因为由<code>windows</code>共享的方式，在<code>Linux</code>上挂载时使用的<code>cifs</code>文件系统，可以用<code>df -T</code>来查看，而<code>cifs</code>文件系统是创建不了软连接的（<code>symbolic link</code>），所以<code>windows</code>的共享方式需要改成<code>NFS</code>的方式（读者可以先去了解<code>HFS</code>和<code>cifs</code>的区别）。<br><img src="3433091-4960ac9fcea91965.png" alt="clipboard.png"><br><code>windows</code>要想通过<code>nfs</code>的方式共享文件，需要安装<code>nfs</code>服务，这里我选择用<code>haneWin NFS</code>。下载和文档链接如下：<br><a href="https://www.hanewin.net/nfs-e.htm" target="_blank" rel="noopener">https://www.hanewin.net/nfs-e.htm</a><br><a href="https://www.hanewin.net/doc/nfs/nfsd.htm" target="_blank" rel="noopener">https://www.hanewin.net/doc/nfs/nfsd.htm</a><br>软件需要破解，可在网上找到注册机。下图是配置图。<br><img src="3433091-5ef1ad52e670fc56.png" alt="clipboard.png"><br><img src="3433091-2152e47cb6e14e17.png" alt="clipboard.png"><br><img src="3433091-2b90dbc679214b9f.png" alt="clipboard.png"><br>上面的参数中<code>-mappall:1000:1000 -exec</code> 是必须的为客户端设置文件夹所属账户以及执行权限，设置完成后重启服务（如果是最新版本直接点击重启服务是可以的，或者到<code>windows</code>的服务管理重启）<br>重启后可在命令行中 <code>showcount -e</code> 进行查看。<br>客户端挂载<pre><code class="c"><span class="comment">//先安装nfs客户端在挂载，原来的挂载取消</span>
$ sudo apt-get install nfs-common
$ sudo mount -t nfs <span class="number">192.168</span><span class="number">.2</span><span class="number">.176</span>:/jvm /home/ccr/jvm/
<span class="comment">//挂载成功后，进入目录测试一下能否创建软连接</span>
$ touch foo  --创建文件
$ ln -s bar foo
</code></pre>
最后运行成功<br><img src="3433091-125985cd43b66e47.png" alt="clipboard.png"><h1 id="NetBeans运行项目。"><a href="#NetBeans运行项目。" class="headerlink" title="NetBeans运行项目。"></a><code>NetBeans</code>运行项目。</h1></li>
<li>准备<code>Hello World class</code>文件（很简单的<code>javaHelloWorld</code>，用<code>openjdk</code>编译好的<code>javac</code>去编译，或者用该版本以下版本去编译。），放到共享文件夹内。我的放在<code>jvm/javatest</code>目录下。</li>
<li>右键项目-&gt;属性-&gt;运行-&gt;编辑运行命令-&gt;输入类路径和类名<br><img src="3433091-5148f13e2c1de5a2.png" alt="clipboard.png"><br><img src="3433091-de8b30d01ef478e5.png" alt="clipboard.png"></li>
<li>好了现在可以运行项目了，点击运行-&gt;运行项目，<code>netbeans</code>会询问你用什么可执行文件来运行，选择<code>java</code>即可<br><img src="3433091-8573cd61828ff74c.png" alt="clipboard.png"><br>运行结果如下：<br><img src="3433091-ba558ae92a1e7273.png" alt="clipboard.png"><h1 id="NetBeans调试项目。"><a href="#NetBeans调试项目。" class="headerlink" title="NetBeans调试项目。"></a>NetBeans调试项目。</h1><code>System.out.println(...)</code>实际上调用的是<code>jdk/src/share/native/java/io/io_util.c</code> 文件中的 <code>writeBytes</code> 方法，定位到这个方法打上断点。点击调试项目，如果出现<code>SIGSEGV</code> 警告，忽略往前继续。最终执行到改断点，你就能看到<code>jvm</code>正在干什么。<br><img src="3433091-b24ad588d9cef967.png" alt="clipboard.png"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>好了，以上就是利用<code>NetBeans</code>远程开发和<code>Linux</code>虚拟机进行的<code>OpenJDK</code>的构建和调试。构建过程中有很多错误，读者要有耐心，利用虚拟机的快照功能对虚拟机进行备份。尽量参考官方的文档。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OpenJDK </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenJDK </tag>
            
            <tag> Netbeans </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
